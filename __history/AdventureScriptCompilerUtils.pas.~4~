unit AdventureScriptCompilerUtils;

interface

uses Sysutils, Variants, FileIOFunctions;

const
  OP_BEGININSTRUCTION = $8000;
  OP_ENDINSTRUCTION = $8001;
  OP_FUNCTIONCALL = $8002;
  OP_IFBEGIN = $8003;
  OP_IFEND = $8004;
  OP_IFELSEBEGIN = $8005;
  OP_IFELSEEND = $8006;
  OP_CONDITION = $8007;
  OP_IF = $8008;
  OP_SETVAR = $8009;
  OP_RANDOMCHANCE = $800A;
  OP_FUNCTIONDEF = $800B;
  OP_FUNCTIONBEGIN = $800C;
  OP_FUNCTIONEND= $800D;
  OP_ADD = $800E;
  OP_SUBTRACT = $800F;
  OP_DIVIDE = $8010;
  OP_MULTIPLY = $8011;
  OP_EXPRESSIONDATA = $8012;

  RETURN_TYPE_VOID = $4000;
  RETURN_TYPE_INTEGER = $4001;
  RETURN_TYPE_STRING = $4002;

  DATA_TYPE_PARAMETER = $A001;
  DATA_TYPE_RETURN_TYPE = $A002;
  DATA_TYPE_FUNCTION_NAME = $A003;
  DATA_TYPE_VAR_NAME = $A004;
  DATA_TYPE_REGULARDATA = $A005;
  DATA_TYPE_TARGETNODE = $A006;
  DATA_TYPE_PROBABILITY = $A007;
  DATA_TYPE_IF_EVAL = $A008;

type
  param = record
    data_type: integer;
    data: variant;
  end;

type
  instruction = record
    inst_type: integer;
    inst_params: array of param;
    inst_paramcount: integer;
  end;

type
  Script = record
    script_name: ansistring;
    script_filename: ansistring;
    script_author: ansistring;
    instructions: array of instruction;
    instruction_count: integer;
  end;

var
  CurrentScript: Script;
 instruction_created: boolean;
 instruction_ended: boolean;

 function AddInstruction(var TheScript: Script; inst_type: integer): instruction;
procedure NextInstruction(var TheScript: Script; prev_instruction: instruction);
procedure AddParam(var instruction: instruction; param: variant; data_type: integer);
procedure InitScriptData(var TheScript: Script; name: ansistring; filename: ansistring; author: ansistring);
procedure SaveScript(thescript: script; filename: string);
function OpcodeToStr(opcode: integer): string;

implementation

function ParamTypeToStr (paramtype: integer): string;
begin
  case paramtype of
       DATA_TYPE_PARAMETER:
       result:='DATA_TYPE_PARAMETER';
       DATA_TYPE_RETURN_TYPE:
       result:='DATA_TYPE_RETURN_TYPE';
       DATA_TYPE_FUNCTION_NAME:
       result:='DATA_TYPE_FUNCTION_NAME';
       DATA_TYPE_VAR_NAME:
       result:='DATA_TYPE_VAR_NAME';
       DATA_TYPE_REGULARDATA:
       result:='DATA_TYPE_REGULARDATA';
       DATA_TYPE_TARGETNODE:
       result:='DATA_TYPE_TARGETNODE';
       DATA_TYPE_PROBABILITY:
       result:='DATA_TYPE_PROBABILITY';
       else
       result:='DATA_TYPE_UNKNOWN';
  end;
end;

function OpcodeToStr(opcode: integer): string;
begin
  case opcode  of
         OP_BEGININSTRUCTION:
         result:='OP_BEGININSTRUCTION';
         OP_ENDINSTRUCTION:
         result :='OP_ENDINSTRUCTION';
         OP_FUNCTIONCALL:
         result:='OP_FUNCTIONCALL';
         OP_IFBEGIN:
         result:='OP_IFBEGIN';
         OP_IFEND:
         result:='OP_IFEND';
         OP_IFELSEBEGIN:
         result:='OP_IFELSEBEGIN';
         OP_CONDITION:
         result:='OP_CONDITION';
         OP_SETVAR:
         result:='OP_SETVAR';
         OP_RANDOMCHANCE:
         result:='OP_RANDOMCHANCE';
         OP_FUNCTIONDEF:
         result:='OP_FUNCTIONDEF';
         OP_FUNCTIONBEGIN:
         result:='OP_FUNCTIONBEGIN';
         OP_FUNCTIONEND:
         result:='OP_FUNCTIONEND';
         OP_ADD:
         result:='OP_ADD';
         OP_SUBTRACT:
         result:='OP_SUBTRACT';
         OP_DIVIDE:
         result:='OP_DIVIDE';
         OP_MULTIPLY:
         result:='OP_MULTIPLY';
         OP_EXPRESSIONDATA:
         result:='OP_EXPRESSIONDATA';
  else
  result:='OP_UNKNOWN';
  end;
end;
procedure SaveScript(thescript: script; filename: string);
var j,i: integer;
var vartype_temp: integer;
var F: file;
begin
  assignfile(f, filename);
  rewrite(f,1);
  WriteStringNoLength(f,'AdventureScript v1.0');
  WriteString(f, thescript.script_name);
  WriteString(f, thescript.script_filename);
  WriteString(f, thescript.script_author);
  for i := 0 to thescript.instruction_count-1 do
  begin
  writeln('Instruction type: '+inttohex(thescript.instructions[i].inst_type)+' - '+opcodetostr(thescript.instructions[i].inst_type));

    BlockWrite(f, thescript.instructions[i].inst_type, 4);
    BlockWrite(f, thescript.instructions[i].inst_paramcount, 4);
  writeln('Instruction paramcount: '+inttostr(thescript.instructions[i].inst_paramcount));
  for j := 0 to thescript.instructions[i].inst_paramcount-1 do
     begin
    writeln('Param: ',thescript.instructions[i].inst_params[j].data,', TYPE: '+paramtypetostr(thescript.instructions[i].inst_params[j].data_type));
    BlockWrite(f, thescript.instructions[i].inst_params[j].data_type, 4);
    vartype_temp := vartype(thescript.instructions[i].inst_params[j].data);
     if vartype(thescript.instructions[i].inst_params[j].data) = varInteger then
    BlockWrite(f, thescript.instructions[i].inst_params[j].data, 4) else
    if (vartype(thescript.instructions[i].inst_params[j].data) = varString)
    or (vartype(thescript.instructions[i].inst_params[j].data) = varUString) then
    writestring(f, thescript.instructions[i].inst_params[j].data) else
    writeln('Unknown vartype! '+inttostr(vartype_temp));


     end;
  end;
  closefile(f);

end;

function AddInstruction(var TheScript: Script; inst_type: integer): instruction;
begin
 instruction_ended:=false;
 instruction_created:=true;
  writeln('AddInstruction('+opcodetostr(inst_type)+')');
  SetLength(TheScript.instructions, TheScript.instruction_count + 1);
  TheScript.instructions[TheScript.instruction_count].inst_type := inst_type;
  result.inst_paramcount:=0;
  SetLength(result.inst_params, 0);
  result := TheScript.instructions[TheScript.instruction_count];
  end;

procedure NextInstruction(var TheScript: Script; prev_instruction: instruction);
begin
if instruction_created=false then
writeln('Warning! NextInstruction() called without creating one first');
instruction_ended := true;
instruction_created:=false;
TheScript.instructions[TheScript.instruction_count] := prev_instruction;
  inc(TheScript.instruction_count);
  writeln('NextInstruction(), previous: '+opcodetostr(prev_instruction.inst_type));
end;

procedure AddParam(var instruction: instruction; param: variant; data_type: integer);
begin
  SetLength(instruction.inst_params, instruction.inst_paramcount + 1);
  instruction.inst_params[instruction.inst_paramcount].data_type := data_type;
  instruction.inst_params[instruction.inst_paramcount].data := param;
  inc(instruction.inst_paramcount);
end;

procedure InitScriptData(var TheScript: Script; name: ansistring; filename: ansistring; author: ansistring);
begin
thescript.script_name := name;
thescript.script_filename := filename;
thescript.script_author := author;
end;

end.
