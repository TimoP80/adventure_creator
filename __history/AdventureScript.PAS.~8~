unit AdventureScript;




{==============================================================================
AdventureScript
Date of Generation: 30.1.2020 21.25

This unit was generated by Coco/R for Delphi (www.tetzel.com)  Any code in
this file that you edit manually will be over-written when the file is
regenerated.
==============================================================================}

interface
uses  Variants,SysUtils,AdventureScriptCompilerUtils,Classes,CocoBase;



const
maxT = 36;
type
  SymbolSet = array[0..maxT div setsize] of TBitSet;

  EAdventureScript = class(Exception);
  TAdventureScript = class;

  TAdventureScriptScanner = class(TCocoRScanner)
  private
    FOwner : TAdventureScript;
procedure CheckLiteral(var Sym : integer);
function Equal(s : string) : boolean;
    function Comment : boolean;
  protected
    procedure NextCh; override;
  public
    constructor Create;

    procedure Get(var sym : integer); override; // Gets next symbol from source file

    property CurrentSymbol;
    property NextSymbol;
    property OnStatusUpdate;
    property Owner : TAdventureScript read fOwner write fOwner;
    property ScannerError;
    property SrcStream;
  end;  { TAdventureScriptScanner }

  TAdventureScript = class(TCocoRGrammar)
  private
    { strictly internal variables }
    symSet : array[0..1] of SymbolSet; // symSet[0] = allSyncSyms

    function _In(var s : SymbolSet; x : integer) : boolean;
    procedure InitSymSet;

    {Production methods}
    procedure _AdventureScript;
    procedure _FuncDefinition;
    procedure _SetVar;
    procedure _RegularExp;
    procedure _Expression;
    procedure _RegularData;
    procedure _RegularCommand;
    procedure _RandomChance;
    procedure _Param;
    procedure _FunctionParam;
    procedure _Command;
    procedure _IfStatement;
    procedure _Conditions;
    procedure _Condition;

  private
    fOutputStream : TMemoryStream;
    fSubSelectDepth : integer;
    fInNaturalJoin : boolean;
            
    procedure Init;
    procedure Final;
                
    property OutputStream : TMemoryStream read fOutputStream write fOutputStream;
    
  protected
    { Protected Declarations }
    procedure Get; override;
  public
    { Public Declarations }
    constructor Create(AOwner : TComponent); override;
    destructor Destroy; override;

    function ErrorStr(const ErrorCode : integer; const Data : ansistring) : ansistring; override;
    procedure Execute;
    function GetScanner : TAdventureScriptScanner;
    procedure Parse;

    property ErrorList;
    property ListStream;
    property SourceStream;
    property Successful;

  published
    { Published Declarations }
    property AfterGet;
    property AfterParse;
    property AfterGenList;
    property BeforeGenList;
    property BeforeParse;
    property ClearSourceStream;
    property GenListWhen;
    property SourceFileName;

    property OnCustomError;
    property OnError;
    property OnFailure;
    property OnStatusUpdate;
    property OnSuccess;
  end; { TAdventureScript }

implementation

var
name_temp: string;
return_type_temp: integer;
instruction_temp: instruction;



const

  EOFSYMB = 0;  identifierSym = 1;  numberSym = 2;  hexnumberSym = 3;
  stringSym = 4;  charSym = 5;  librarySym = 6;  _lparenSym = 7;
  _equal_equalSym = 8;  _bang_equalSym = 9;  _greaterSym = 10;
  _greater_equalSym = 11;  _less_equalSym = 12;  _lessSym = 13;
  _rparenSym = 14;  _and_andSym = 15;  _barSym = 16;  IFSym = 17;
  _lbraceSym = 18;  _rbraceSym = 19;  ELSESym = 20;  INTSym = 21;  STRSym = 22;
  RANDOMCHANCESym = 23;  SETSym = 24;  TARGET_underscoreNODESym = 25;
  _commaSym = 26;  _plusSym = 27;  _minusSym = 28;  _slashSym = 29;
  _starSym = 30;  SETVARSym = 31;  _dollarSym = 32;  _equalSym = 33;
  _semicolonSym = 34;  VOIDSym = 35;  NOSYMB = 36;  _noSym = NOSYMB;   {error token code}

{ --------------------------------------------------------------------------- }
{ Arbitrary Code from ATG file }
const
  PadLen = 20;
                        
function PadR(S : string; Ch : char; L : integer) : string;
var
  i : integer;
begin
  for i := 1 to L - (Length(s)) do
    s := s + Ch;
  Result := s;
end;

procedure TAdventureScript.Init;
begin
  OutputStream.Clear;

 end;

procedure TAdventureScript.Final;
begin
   OutputStream.Position := 0;
  OutputStream.SaveToStream(ListStream);
  OutputStream.Clear;
end;
                                 
                                 
function parse_string(zstr: string): string;
var t:    integer;
var temp: string;
var len:  integer;
begin;
  len := 0;
  temp:='';
  //writeln ('Parsing string: ',zstr);
  t   := pos('"', zstr) + 1;
  len := length(zstr);
  while (zstr[t] <> '"') do
  begin;
    //writeln (zstr[t]);
    if (zstr[t] = '\') and (zstr[t + 1] = '"') then
    begin;
      temp := temp + '"';
      Inc(t, 1);
    end else
    if (zstr[t] = '\') and (zstr[t + 1] = 't') then
    begin;
      temp := temp + #9;
      Inc(t, 1);
    end else
    if (zstr[t] = '\') and (zstr[t + 1] = 'n') then
    begin;
      temp := temp + #13#10;
      Inc(t, 1);
    end else

      temp := temp + zstr[t];

    Inc(t);
  end;
   Result := utf8tostring(temp);
end;


(* End of Arbitrary Code *)



{ --------------------------------------------------------------------------- }
{ ---- implementation for TAdventureScriptScanner ---- }

procedure TAdventureScriptScanner.NextCh;
{ Return global variable ch }
begin
  LastInputCh := CurrInputCh;
  BufferPosition := BufferPosition + 1;
  SrcStream.Seek(BufferPosition,soFromBeginning);
  CurrInputCh := CurrentCh(BufferPosition);
  if (CurrInputCh = _EL) OR ((CurrInputCh = _LF) AND (LastInputCh <> _EL)) then
  begin
    CurrLine := CurrLine + 1;
    if Assigned(OnStatusUpdate) then
      OnStatusUpdate(Owner, cstLineNum, '', CurrLine);
    StartOfLine := BufferPosition;
  end
end;  {NextCh}

function TAdventureScriptScanner.Comment : boolean;
var
  level : integer;
  oldLineStart : longint;
  CommentStr : string;
begin
  level := 1;
  oldLineStart := StartOfLine;
  CommentStr := CharAt(BufferPosition);
Result := false;
if (CurrInputCh = '/') then
  begin
NextCh;
CommentStr := CommentStr + CharAt(BufferPosition);
if (CurrInputCh = '*') then
begin
NextCh;
CommentStr := CommentStr + CharAt(BufferPosition);
while true do
begin
if (CurrInputCh = '*') then
begin
NextCh;
CommentStr := CommentStr + CharAt(BufferPosition);
if (CurrInputCh = '/') then
begin
level := level - 1;
NextCh;
CommentStr := CommentStr + CharAt(BufferPosition);
if level = 0 then
begin
  Result := true;
  Exit;
end
end
end
else if CurrInputCh = _EF then
begin
  Result := false;
  Exit;
end
else
begin
  NextCh;
  CommentStr := CommentStr + CharAt(BufferPosition);
end;
end; { WHILE TRUE }
end
else
begin
if (CurrInputCh = _CR) OR (CurrInputCh = _LF) then
begin
CurrLine := CurrLine - 1;
StartOfLine := oldLineStart
end;
BufferPosition := BufferPosition - 1;
CurrInputCh := LastInputCh;
Result := false;
end;
end;
end;  { Comment }

function TAdventureScriptScanner.Equal(s : string) : boolean;
var
  i : integer;
  q : longint;
begin
  if NextSymbol.Len <> Length(s) then
  begin
    Result := false;
    EXIT
  end;
  i := 1;
  q := bpCurrToken;
  while i <= NextSymbol.Len do
  begin
    if CurrentCh(q) <> s[i] then
    begin
      Result := false;
      EXIT;
    end;
    inc(i);
    inc(q);
  end;
  Result := true
end;  {Equal}

procedure TAdventureScriptScanner.CheckLiteral(var Sym : integer);
begin
case CurrentCh(bpCurrToken) of
  'E': if Equal('ELSE') then
begin
sym := ELSESym;
end;

  'I': if Equal('IF') then
begin
sym := IFSym;
end
else if Equal('INT') then
begin
sym := INTSym;
end;

  'R': if Equal('RANDOMCHANCE') then
begin
sym := RANDOMCHANCESym;
end;

  'S': if Equal('SET') then
begin
sym := SETSym;
end
else if Equal('SETVAR') then
begin
sym := SETVARSym;
end
else if Equal('STR') then
begin
sym := STRSym;
end;

  'T': if Equal('TARGET_NODE') then
begin
sym := TARGET_underscoreNODESym;
end;

  'V': if Equal('VOID') then
begin
sym := VOIDSym;
end;

else
begin
end
end
end; {CheckLiteral}


procedure TAdventureScriptScanner.Get(var sym : integer);
var
  state : integer;
begin   {Get}
while (CurrInputCh = ' ') OR
((CurrInputCh >= CHR(1)) AND (CurrInputCh <= ' ')) do
  NextCh;
if ((CurrInputCh = '/')) AND Comment then
begin
  Get(sym);
  exit;
  end;

  CurrentSymbol.Assign(NextSymbol);

  NextSymbol.Pos := BufferPosition;
  NextSymbol.Col := BufferPosition - StartOfLine;
  NextSymbol.Line := CurrLine;
  NextSymbol.Len := 0;

  ContextLen := 0;
  state := StartState[ORD(CurrInputCh)];
  bpCurrToken := BufferPosition;
  while true do
  begin
    NextCh;
    NextSymbol.Len := NextSymbol.Len + 1;
    if BufferPosition > SrcStream.Size then
    begin
      sym := EOFSYMB;
      CurrInputCh := _EF;
      BufferPosition := BufferPosition - 1;
      exit
    end;
    case state of
   1: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
 
end
else
begin
sym := identifierSym;
CheckLiteral(sym);
exit;
end;
   2: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
 
end
else if ((CurrInputCh = 'L') OR
(CurrInputCh = 'U')) then
begin
state := 15; 
end
else if (CurrInputCh = '.') then
begin
state := 3; 
end
else
begin
sym := numberSym;
exit;
end;
   3: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
 
end
else if ((CurrInputCh = 'L') OR
(CurrInputCh = 'U')) then
begin
state := 15; 
end
else
begin
sym := numberSym;
exit;
end;
   4: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F')) then
begin
state := 5; 
end
else
begin
  sym := _noSym;
exit;
end;
   5: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F')) then
begin
 
end
else if ((CurrInputCh = 'L') OR
(CurrInputCh = 'U')) then
begin
state := 16; 
end
else
begin
sym := hexnumberSym;
exit;
end;
   6: if ((CurrInputCh >= ' ') AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#')) then
begin
 
end
else if (CurrInputCh = '"') then
begin
state := 7; 
end
else
begin
  sym := _noSym;
exit;
end;
   7: begin
sym := stringSym;
exit;
end;
   8: if ((CurrInputCh >= ' ') AND (CurrInputCh <= '&') OR
(CurrInputCh >= '(') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']')) then
begin
state := 9; 
end
else if (CurrInputCh = '\') then
begin
state := 17; 
end
else
begin
  sym := _noSym;
exit;
end;
   9: if (CurrInputCh = CHR(39)) then
begin
state := 10; 
end
else
begin
  sym := _noSym;
exit;
end;
  10: begin
sym := charSym;
exit;
end;
  11: if ((CurrInputCh = '.') OR
(CurrInputCh >= '0') AND (CurrInputCh <= ':') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '\')) then
begin
state := 12; 
end
else if (CurrInputCh = '=') then
begin
state := 25; 
end
else
begin
sym := _lessSym;
exit;
end;
  12: if ((CurrInputCh = '.') OR
(CurrInputCh >= '0') AND (CurrInputCh <= ':') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '\')) then
begin
 
end
else if (CurrInputCh = '>') then
begin
state := 13; 
end
else
begin
  sym := _noSym;
exit;
end;
  13: begin
sym := librarySym;
exit;
end;
  14: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
state := 2; 
end
else if ((CurrInputCh = 'L') OR
(CurrInputCh = 'U')) then
begin
state := 15; 
end
else if (CurrInputCh = '.') then
begin
state := 3; 
end
else if (CurrInputCh = 'X') then
begin
state := 4; 
end
else
begin
sym := numberSym;
exit;
end;
  15: begin
sym := numberSym;
exit;
end;
  16: begin
sym := hexnumberSym;
exit;
end;
  17: if ((CurrInputCh >= ' ') AND (CurrInputCh <= '&') OR
(CurrInputCh >= '(')) then
begin
state := 9; 
end
else if (CurrInputCh = CHR(39)) then
begin
state := 10; 
end
else
begin
  sym := _noSym;
exit;
end;
  18: begin
sym := _lparenSym;
exit;
end;
  19: if (CurrInputCh = '=') then
begin
state := 20; 
end
else
begin
sym := _equalSym;
exit;
end;
  20: begin
sym := _equal_equalSym;
exit;
end;
  21: if (CurrInputCh = '=') then
begin
state := 22; 
end
else
begin
  sym := _noSym;
exit;
end;
  22: begin
sym := _bang_equalSym;
exit;
end;
  23: if (CurrInputCh = '=') then
begin
state := 24; 
end
else
begin
sym := _greaterSym;
exit;
end;
  24: begin
sym := _greater_equalSym;
exit;
end;
  25: begin
sym := _less_equalSym;
exit;
end;
  26: begin
sym := _rparenSym;
exit;
end;
  27: if (CurrInputCh = '&') then
begin
state := 28; 
end
else
begin
  sym := _noSym;
exit;
end;
  28: begin
sym := _and_andSym;
exit;
end;
  29: begin
sym := _barSym;
exit;
end;
  30: begin
sym := _lbraceSym;
exit;
end;
  31: begin
sym := _rbraceSym;
exit;
end;
  32: begin
sym := _commaSym;
exit;
end;
  33: begin
sym := _plusSym;
exit;
end;
  34: begin
sym := _minusSym;
exit;
end;
  35: begin
sym := _slashSym;
exit;
end;
  36: begin
sym := _starSym;
exit;
end;
  37: begin
sym := _dollarSym;
exit;
end;
  38: begin
sym := _semicolonSym;
exit;
end;
  39: begin
sym := EOFSYMB;
CurrInputCh := #0;
BufferPosition := BufferPosition - 1;
exit
end;
    else
      begin
        sym := _noSym;
        EXIT;          // NextCh already done
      end;
    end;
  end;
end;  {Get}

constructor TAdventureScriptScanner.Create;
begin
  inherited;
CurrentCh := CapChAt;
fStartState[  0] := 39; fStartState[  1] := 40; fStartState[  2] := 40; fStartState[  3] := 40; 
fStartState[  4] := 40; fStartState[  5] := 40; fStartState[  6] := 40; fStartState[  7] := 40; 
fStartState[  8] := 40; fStartState[  9] := 40; fStartState[ 10] := 40; fStartState[ 11] := 40; 
fStartState[ 12] := 40; fStartState[ 13] := 40; fStartState[ 14] := 40; fStartState[ 15] := 40; 
fStartState[ 16] := 40; fStartState[ 17] := 40; fStartState[ 18] := 40; fStartState[ 19] := 40; 
fStartState[ 20] := 40; fStartState[ 21] := 40; fStartState[ 22] := 40; fStartState[ 23] := 40; 
fStartState[ 24] := 40; fStartState[ 25] := 40; fStartState[ 26] := 40; fStartState[ 27] := 40; 
fStartState[ 28] := 40; fStartState[ 29] := 40; fStartState[ 30] := 40; fStartState[ 31] := 40; 
fStartState[ 32] := 40; fStartState[ 33] := 21; fStartState[ 34] :=  6; fStartState[ 35] := 40; 
fStartState[ 36] := 37; fStartState[ 37] := 40; fStartState[ 38] := 27; fStartState[ 39] :=  8; 
fStartState[ 40] := 18; fStartState[ 41] := 26; fStartState[ 42] := 36; fStartState[ 43] := 33; 
fStartState[ 44] := 32; fStartState[ 45] := 34; fStartState[ 46] := 40; fStartState[ 47] := 35; 
fStartState[ 48] := 14; fStartState[ 49] :=  2; fStartState[ 50] :=  2; fStartState[ 51] :=  2; 
fStartState[ 52] :=  2; fStartState[ 53] :=  2; fStartState[ 54] :=  2; fStartState[ 55] :=  2; 
fStartState[ 56] :=  2; fStartState[ 57] :=  2; fStartState[ 58] := 40; fStartState[ 59] := 38; 
fStartState[ 60] := 11; fStartState[ 61] := 19; fStartState[ 62] := 23; fStartState[ 63] := 40; 
fStartState[ 64] := 40; fStartState[ 65] :=  1; fStartState[ 66] :=  1; fStartState[ 67] :=  1; 
fStartState[ 68] :=  1; fStartState[ 69] :=  1; fStartState[ 70] :=  1; fStartState[ 71] :=  1; 
fStartState[ 72] :=  1; fStartState[ 73] :=  1; fStartState[ 74] :=  1; fStartState[ 75] :=  1; 
fStartState[ 76] :=  1; fStartState[ 77] :=  1; fStartState[ 78] :=  1; fStartState[ 79] :=  1; 
fStartState[ 80] :=  1; fStartState[ 81] :=  1; fStartState[ 82] :=  1; fStartState[ 83] :=  1; 
fStartState[ 84] :=  1; fStartState[ 85] :=  1; fStartState[ 86] :=  1; fStartState[ 87] :=  1; 
fStartState[ 88] :=  1; fStartState[ 89] :=  1; fStartState[ 90] :=  1; fStartState[ 91] := 40; 
fStartState[ 92] := 40; fStartState[ 93] := 40; fStartState[ 94] := 40; fStartState[ 95] :=  1; 
fStartState[ 96] := 40; fStartState[ 97] := 40; fStartState[ 98] := 40; fStartState[ 99] := 40; 
fStartState[100] := 40; fStartState[101] := 40; fStartState[102] := 40; fStartState[103] := 40; 
fStartState[104] := 40; fStartState[105] := 40; fStartState[106] := 40; fStartState[107] := 40; 
fStartState[108] := 40; fStartState[109] := 40; fStartState[110] := 40; fStartState[111] := 40; 
fStartState[112] := 40; fStartState[113] := 40; fStartState[114] := 40; fStartState[115] := 40; 
fStartState[116] := 40; fStartState[117] := 40; fStartState[118] := 40; fStartState[119] := 40; 
fStartState[120] := 40; fStartState[121] := 40; fStartState[122] := 40; fStartState[123] := 30; 
fStartState[124] := 29; fStartState[125] := 31; fStartState[126] := 40; fStartState[127] := 40; 
fStartState[128] := 40; fStartState[129] := 40; fStartState[130] := 40; fStartState[131] := 40; 
fStartState[132] := 40; fStartState[133] := 40; fStartState[134] := 40; fStartState[135] := 40; 
fStartState[136] := 40; fStartState[137] := 40; fStartState[138] := 40; fStartState[139] := 40; 
fStartState[140] := 40; fStartState[141] := 40; fStartState[142] := 40; fStartState[143] := 40; 
fStartState[144] := 40; fStartState[145] := 40; fStartState[146] := 40; fStartState[147] := 40; 
fStartState[148] := 40; fStartState[149] := 40; fStartState[150] := 40; fStartState[151] := 40; 
fStartState[152] := 40; fStartState[153] := 40; fStartState[154] := 40; fStartState[155] := 40; 
fStartState[156] := 40; fStartState[157] := 40; fStartState[158] := 40; fStartState[159] := 40; 
fStartState[160] := 40; fStartState[161] := 40; fStartState[162] := 40; fStartState[163] := 40; 
fStartState[164] := 40; fStartState[165] := 40; fStartState[166] := 40; fStartState[167] := 40; 
fStartState[168] := 40; fStartState[169] := 40; fStartState[170] := 40; fStartState[171] := 40; 
fStartState[172] := 40; fStartState[173] := 40; fStartState[174] := 40; fStartState[175] := 40; 
fStartState[176] := 40; fStartState[177] := 40; fStartState[178] := 40; fStartState[179] := 40; 
fStartState[180] := 40; fStartState[181] := 40; fStartState[182] := 40; fStartState[183] := 40; 
fStartState[184] := 40; fStartState[185] := 40; fStartState[186] := 40; fStartState[187] := 40; 
fStartState[188] := 40; fStartState[189] := 40; fStartState[190] := 40; fStartState[191] := 40; 
fStartState[192] := 40; fStartState[193] := 40; fStartState[194] := 40; fStartState[195] := 40; 
fStartState[196] := 40; fStartState[197] := 40; fStartState[198] := 40; fStartState[199] := 40; 
fStartState[200] := 40; fStartState[201] := 40; fStartState[202] := 40; fStartState[203] := 40; 
fStartState[204] := 40; fStartState[205] := 40; fStartState[206] := 40; fStartState[207] := 40; 
fStartState[208] := 40; fStartState[209] := 40; fStartState[210] := 40; fStartState[211] := 40; 
fStartState[212] := 40; fStartState[213] := 40; fStartState[214] := 40; fStartState[215] := 40; 
fStartState[216] := 40; fStartState[217] := 40; fStartState[218] := 40; fStartState[219] := 40; 
fStartState[220] := 40; fStartState[221] := 40; fStartState[222] := 40; fStartState[223] := 40; 
fStartState[224] := 40; fStartState[225] := 40; fStartState[226] := 40; fStartState[227] := 40; 
fStartState[228] := 40; fStartState[229] := 40; fStartState[230] := 40; fStartState[231] := 40; 
fStartState[232] := 40; fStartState[233] := 40; fStartState[234] := 40; fStartState[235] := 40; 
fStartState[236] := 40; fStartState[237] := 40; fStartState[238] := 40; fStartState[239] := 40; 
fStartState[240] := 40; fStartState[241] := 40; fStartState[242] := 40; fStartState[243] := 40; 
fStartState[244] := 40; fStartState[245] := 40; fStartState[246] := 40; fStartState[247] := 40; 
fStartState[248] := 40; fStartState[249] := 40; fStartState[250] := 40; fStartState[251] := 40; 
fStartState[252] := 40; fStartState[253] := 40; fStartState[254] := 40; fStartState[255] := 40; 
end; {Create}


{ --------------------------------------------------------------------------- }
{ ---- implementation for TAdventureScript ---- }

constructor TAdventureScript.Create(AOwner : TComponent);
begin
  inherited;
  Scanner := TAdventureScriptScanner.Create;
  GetScanner.Owner := self;
fOutputStream := TMemoryStream.Create;
  
  InitSymSet;
end; {Create}

destructor TAdventureScript.Destroy;
begin
  Scanner.Free;
fOutputStream.Free;
  
  inherited;
end; {Destroy}

function TAdventureScript.ErrorStr(const ErrorCode : integer; const Data : ansistring) : ansistring;
begin
  case ErrorCode of
       0 : Result := 'EOF expected';
   1 : Result := 'identifier expected';
   2 : Result := 'number expected';
   3 : Result := 'hexnumber expected';
   4 : Result := 'string expected';
   5 : Result := 'char expected';
   6 : Result := 'library expected';
   7 : Result := '"(" expected';
   8 : Result := '"==" expected';
   9 : Result := '"!=" expected';
  10 : Result := '">" expected';
  11 : Result := '">=" expected';
  12 : Result := '"<=" expected';
  13 : Result := '"<" expected';
  14 : Result := '")" expected';
  15 : Result := '"&&" expected';
  16 : Result := '"|" expected';
  17 : Result := '"IF" expected';
  18 : Result := '"{" expected';
  19 : Result := '"}" expected';
  20 : Result := '"ELSE" expected';
  21 : Result := '"INT" expected';
  22 : Result := '"STR" expected';
  23 : Result := '"RANDOMCHANCE" expected';
  24 : Result := '"SET" expected';
  25 : Result := '"TARGET_NODE" expected';
  26 : Result := '"," expected';
  27 : Result := '"+" expected';
  28 : Result := '"-" expected';
  29 : Result := '"/" expected';
  30 : Result := '"*" expected';
  31 : Result := '"SETVAR" expected';
  32 : Result := '"$" expected';
  33 : Result := '"=" expected';
  34 : Result := '";" expected';
  35 : Result := '"VOID" expected';
  36 : Result := 'not expected';
  37 : Result := 'invalid FuncDefinition';
  38 : Result := 'invalid SetVar';
  39 : Result := 'invalid Expression';
  40 : Result := 'invalid RegularData';
  41 : Result := 'invalid Param';
  42 : Result := 'invalid FunctionParam';
  43 : Result := 'invalid FunctionParam';
  44 : Result := 'invalid Command';
  45 : Result := 'invalid Condition';
  46 : Result := 'invalid Condition';


  else
    if Assigned(OnCustomError) then
      Result := OnCustomError(Self, ErrorCode, Data)
    else
    begin
      Result := 'Error: ' + IntToStr(ErrorCode);
      if Trim(Data) > '' then
        Result := Result + ' (' + Data + ')';
    end;
  end;  {case nr}
end; {ErrorStr}

procedure TAdventureScript.Execute;
begin
  ClearErrors;
  ListStream.Clear;
  Extra := 1;

  { if there is a file name then load the file }
  if Trim(SourceFileName) <> '' then
  begin
    GetScanner.SrcStream.Clear;
    GetScanner.SrcStream.LoadFromFile(SourceFileName);
  end;

  { install error reporting procedure }
  GetScanner.ScannerError := StoreError;

  { instigate the compilation }
  DoBeforeParse;
  Parse;
  DoAfterParse;

  { generate the source listing to the ListStream }
  if (GenListWhen = glAlways) OR ((GenListWhen = glOnError) AND (ErrorList.Count > 0)) then
    GenerateListing;
  if ClearSourceStream then
    GetScanner.SrcStream.Clear;
  ListStream.Position := 0;  // goto the beginning of the stream
  if Successful AND Assigned(OnSuccess) then
    OnSuccess(Self);
  if (NOT Successful) AND Assigned(OnFailure) then
    OnFailure(Self, ErrorList.Count);
end;  {Execute}

procedure TAdventureScript.Get;
begin
  repeat


    GetScanner.Get(fCurrentInputSymbol);
    if fCurrentInputSymbol <= maxT then
      errDist := errDist + 1
    else
    begin
    end;
  until fCurrentInputSymbol <= maxT;
  if Assigned(AfterGet) then
    AfterGet(Self, fCurrentInputSymbol);
end;  {Get}

function TAdventureScript.GetScanner : TAdventureScriptScanner;
begin
  Result := Scanner AS TAdventureScriptScanner;
end; {GetScanner}

function TAdventureScript._In(var s : SymbolSet; x : integer) : boolean;
begin
  _In := x mod setsize in s[x div setsize];
end;  {_In}

procedure TAdventureScript._AdventureScript;begin
_FuncDefinition;
while (fCurrentInputSymbol = INTSym) OR
 (fCurrentInputSymbol = STRSym) OR
 (fCurrentInputSymbol = VOIDSym) do begin
_FuncDefinition;
end;
end;

procedure TAdventureScript._FuncDefinition;begin
if (fCurrentInputSymbol = INTSym) then begin
Get;

  return_type_temp  :=  RETURN_TYPE_INTEGER;


end else if (fCurrentInputSymbol = VOIDSym) then begin
Get;

  return_type_temp  :=  RETURN_TYPE_VOID;


end else if (fCurrentInputSymbol = STRSym) then begin
Get;

   return_type_temp  :=  RETURN_TYPE_STRING;


end else begin SynError(37);
end;
Expect(identifierSym);

name_temp  :=  lexstring;
instruction_temp  :=  AddInstruction(CurrentScript,  OP_FUNCTIONDEF);
AddParam(instruction_temp,  name_temp,  DATA_TYPE_FUNCTION_NAME);
AddParam(instruction_temp,  return_type_temp,  DATA_TYPE_RETURN_TYPE);
NextInstruction(CurrentScript,  instruction_temp);


Expect(_lparenSym);
if (fCurrentInputSymbol = INTSym) OR
 (fCurrentInputSymbol = STRSym) then begin
_FunctionParam;
while (fCurrentInputSymbol = _commaSym) do begin
Get;
_FunctionParam;
end;
end;
Expect(_rparenSym);
Expect(_lbraceSym);

instruction_temp  :=  AddInstruction(CurrentScript,  OP_FUNCTIONBEGIN);
NextInstruction(CurrentScript,  instruction_temp);

while (fCurrentInputSymbol = identifierSym) OR
 (fCurrentInputSymbol = IFSym) OR
 (fCurrentInputSymbol = RANDOMCHANCESym) OR
 (fCurrentInputSymbol = SETVARSym) do begin
if (fCurrentInputSymbol = identifierSym) OR
 (fCurrentInputSymbol = RANDOMCHANCESym) OR
 (fCurrentInputSymbol = SETVARSym) then begin
_Command;
end else begin
_IfStatement;
end;
end;
Expect(_rbraceSym);

instruction_temp  :=  AddInstruction(CurrentScript,  OP_FUNCTIONEND);
NextInstruction(CurrentScript,  instruction_temp);

end;

procedure TAdventureScript._SetVar;begin
Expect(SETVARSym);
Expect(_dollarSym);
Expect(identifierSym);


instruction_temp  :=  AddInstruction(currentscript,  OP_BEGININSTRUCTION);
NextInstruction(CurrentScript,  instruction_temp);
name_temp  :=  lexstring;
instruction_temp  :=AddInstruction(currentscript,  OP_SETVAR);
AddParam(instruction_temp,  name_temp,  DATA_TYPE_VAR_NAME);
NextInstruction(CurrentScript,  instruction_temp);


Expect(_equalSym);
if (fCurrentInputSymbol = identifierSym) then begin
_RegularCommand;

instruction_temp  :=  AddInstruction(currentscript,  OP_ENDINSTRUCTION);
NextInstruction(CurrentScript,  instruction_temp);


end else if (fCurrentInputSymbol = identifierSym) OR
 (fCurrentInputSymbol = numberSym) OR
 (fCurrentInputSymbol = stringSym) then begin
_RegularExp;
end else begin SynError(38);
end;
end;

procedure TAdventureScript._RegularExp;begin

instruction_temp  :=  AddInstruction(currentscript,  OP_EXPRESSIONDATA);


_RegularData;
while _In(symSet[1], fCurrentInputSymbol) do begin
_Expression;

NextInstruction(currentscript,  instruction_temp);


instruction_temp  :=  AddInstruction(currentscript,  OP_EXPRESSIONDATA);


_RegularData;
end;
end;

procedure TAdventureScript._Expression;begin
if (fCurrentInputSymbol = _plusSym) then begin
Get;

   instruction_temp  :=  AddInstruction(currentscript,  OP_ADD);

end else if (fCurrentInputSymbol = _minusSym) then begin
Get;
end else if (fCurrentInputSymbol = identifierSym) OR
 (fCurrentInputSymbol = numberSym) OR
 (fCurrentInputSymbol = stringSym) then begin

   instruction_temp  :=  AddInstruction(currentscript,  OP_SUBTRACT);


end else if (fCurrentInputSymbol = _slashSym) then begin
Get;

   instruction_temp  :=  AddInstruction(currentscript,  OP_DIVIDE);


end else if (fCurrentInputSymbol = _starSym) then begin
Get;

  instruction_temp  :=  AddInstruction(currentscript,  OP_MULTIPLY);


end else begin SynError(39);
end;
end;

procedure TAdventureScript._RegularData;begin
if (fCurrentInputSymbol = identifierSym) then begin
Get;

AddParam(instruction_temp,  lexstring,  DATA_TYPE_REGULARDATA);
NextInstruction(currentscript,  instruction_temp);


end else if (fCurrentInputSymbol = numberSym) then begin
Get;

AddParam(instruction_temp,  VarAsType(strtoint(lexstring),  VarInteger),  DATA_TYPE_REGULARDATA);
NextInstruction(currentscript,  instruction_temp);


end else if (fCurrentInputSymbol = stringSym) then begin
Get;

AddParam(instruction_temp,  parse_string(lexstring),  DATA_TYPE_REGULARDATA);
NextInstruction(currentscript,  instruction_temp);


end else begin SynError(40);
end;
end;

procedure TAdventureScript._RegularCommand;begin
Expect(identifierSym);


instruction_temp  :=  AddInstruction(currentscript,  OP_FUNCTIONCALL);
if  (isValidFunctionName(CurrentScript,lexstring)=false)  then
begin
SemError(47,  lexstring);
end;
AddParam(instruction_temp,  lexstring,  DATA_TYPE_FUNCTION_NAME);


Expect(_lparenSym);
if (fCurrentInputSymbol = identifierSym) OR
 (fCurrentInputSymbol = numberSym) OR
 (fCurrentInputSymbol = stringSym) then begin
_Param;
while (fCurrentInputSymbol = _commaSym) do begin
Get;
_Param;
end;
end;
Expect(_rparenSym);

NextInstruction(CurrentScript,instruction_temp);

end;

procedure TAdventureScript._RandomChance;begin
Expect(RANDOMCHANCESym);

instruction_temp  :=  AddInstruction(CurrentScript,  OP_RANDOMCHANCE);


Expect(_lparenSym);
Expect(numberSym);

AddParam(instruction_temp,  strtoint(lexstring),  DATA_TYPE_PROBABILITY);


Expect(_rparenSym);
Expect(SETSym);
Expect(TARGET_underscoreNODESym);
Expect(stringSym);

AddParam(instruction_temp,  parse_string(lexstring),  DATA_TYPE_TARGETNODE);
NextInstruction(currentscript,instruction_temp);


end;

procedure TAdventureScript._Param;begin
if (fCurrentInputSymbol = stringSym) then begin
Get;

AddParam(instruction_temp,  parse_string(lexstring),  DATA_TYPE_PARAMETER_STRING);

end else if (fCurrentInputSymbol = numberSym) then begin
Get;

AddParam(instruction_temp,  strtoint(lexstring),  DATA_TYPE_PARAMETER_INT);


end else if (fCurrentInputSymbol = identifierSym) then begin
Get;

AddParam(instruction_temp,  lexstring,  DATA_TYPE_PARAMETER_VARIABLEDEF);


end else begin SynError(41);
end;
end;

procedure TAdventureScript._FunctionParam;begin
if (fCurrentInputSymbol = INTSym) then begin
Get;

AddParam(instruction_temp,  PARAM_TYPE_INT,  DATA_TYPE_FUNCTION_PARAMETER_TYPE);


end else if (fCurrentInputSymbol = STRSym) then begin
Get;

AddParam(instruction_temp,  PARAM_TYPE_STRING,  DATA_TYPE_FUNCTION_PARAMETER_TYPE);

end else begin SynError(42);
end;
if (fCurrentInputSymbol = stringSym) then begin
Get;

AddParam(instruction_temp,  parse_string(lexstring),  DATA_TYPE_FUNCTION_PARAMETER);

end else if (fCurrentInputSymbol = numberSym) then begin
Get;

AddParam(instruction_temp,  strtoint(lexstring),  DATA_TYPE_FUNCTION_PARAMETER);


end else if (fCurrentInputSymbol = identifierSym) then begin
Get;

AddParam(instruction_temp,  lexstring,  DATA_TYPE_FUNCTION_PARAMETER);


end else begin SynError(43);
end;
end;

procedure TAdventureScript._Command;begin
if (fCurrentInputSymbol = identifierSym) then begin
_RegularCommand;
end else if (fCurrentInputSymbol = SETVARSym) then begin
_SetVar;
end else if (fCurrentInputSymbol = RANDOMCHANCESym) then begin
_RandomChance;
end else begin SynError(44);
end;
Expect(_semicolonSym);
end;

procedure TAdventureScript._IfStatement;begin
Expect(IFSym);

instruction_temp  :=  AddInstruction(CurrentScript,  OP_IF);
NextInstruction(currentscript,  instruction_temp);

_Conditions;
Expect(_lbraceSym);

instruction_temp  :=  AddInstruction(CurrentScript,  OP_IFBEGIN);
NextInstruction(currentscript,  instruction_temp);


while (fCurrentInputSymbol = identifierSym) OR
 (fCurrentInputSymbol = RANDOMCHANCESym) OR
 (fCurrentInputSymbol = SETVARSym) do begin
_Command;
end;
Expect(_rbraceSym);

instruction_temp  :=  AddInstruction(CurrentScript,  OP_IFEND);
NextInstruction(currentscript,  instruction_temp);


if (fCurrentInputSymbol = ELSESym) then begin
Get;
if (fCurrentInputSymbol = IFSym) then begin
Get;

instruction_temp  :=  AddInstruction(CurrentScript,  OP_IF);
NextInstruction(currentscript,  instruction_temp);


_Conditions;
end;
Expect(_lbraceSym);

instruction_temp  :=  AddInstruction(CurrentScript,  OP_IFELSEBEGIN);
NextInstruction(currentscript,  instruction_temp);


while (fCurrentInputSymbol = identifierSym) OR
 (fCurrentInputSymbol = RANDOMCHANCESym) OR
 (fCurrentInputSymbol = SETVARSym) do begin
_Command;
end;
Expect(_rbraceSym);
end;


instruction_temp  :=  AddInstruction(CurrentScript,  OP_IFELSEEND);
NextInstruction(currentscript,  instruction_temp);


end;

procedure TAdventureScript._Conditions;begin
_Condition;
while (fCurrentInputSymbol = _and_andSym) OR
 (fCurrentInputSymbol = _barSym) do begin
if (fCurrentInputSymbol = _and_andSym) then begin
Get;


    instruction_temp  :=  AddInstruction(CurrentScript,  OP_IF_CONNECTOR);
    AddParam(instruction_temp,  IF_CONNECT_AND,  DATA_TYPE_IF_CONNECTOR);
    NextInstruction(CurrentScript,  instruction_temp);


end else begin
Get;

    instruction_temp  :=  AddInstruction(CurrentScript,  OP_IF_CONNECTOR);
    AddParam(instruction_temp,  IF_CONNECT_OR,  DATA_TYPE_IF_CONNECTOR);
    NextInstruction(CurrentScript,  instruction_temp);


end;
_Condition;
end;
end;

procedure TAdventureScript._Condition;begin

instruction_temp  :=  AddInstruction(CurrentScript,  OP_CONDITION);

Expect(_lparenSym);
Expect(identifierSym);


AddParam(instruction_temp,  LexString,  DATA_TYPE_IF_VARIABLE);


case fCurrentInputSymbol of
  _equal_equalSym : begin
Get;

AddParam(instruction_temp,  IF_EVAL_EQUALS,  DATA_TYPE_IF_EVAL);

    end;
  _bang_equalSym : begin
Get;


AddParam(instruction_temp,  IF_EVAL_NOT_EQUAL,  DATA_TYPE_IF_EVAL);



    end;
  _greaterSym : begin
Get;


AddParam(instruction_temp,  IF_EVAL_LARGER,  DATA_TYPE_IF_EVAL);


    end;
  _greater_equalSym : begin
Get;

AddParam(instruction_temp,  IF_EVAL_LARGER_OR_EQUAL,  DATA_TYPE_IF_EVAL);


    end;
  _less_equalSym : begin
Get;


AddParam(instruction_temp,  IF_EVAL_LESS_OR_EQUAL,  DATA_TYPE_IF_EVAL);


    end;
  _lessSym : begin
Get;

AddParam(instruction_temp,  IF_EVAL_LESS,  DATA_TYPE_IF_EVAL);


    end;
else begin SynError(45);
    end;
end;
if (fCurrentInputSymbol = stringSym) then begin
Get;

AddParam(instruction_temp,  parse_string(lexstring),  DATA_TYPE_IF_VALUE);


end else if (fCurrentInputSymbol = numberSym) then begin
Get;

AddParam(instruction_temp,  strtoint(lexstring),  DATA_TYPE_IF_VALUE);


end else if (fCurrentInputSymbol = identifierSym) then begin
Get;

AddParam(instruction_temp,  lexstring,  DATA_TYPE_IF_VALUE);


end else begin SynError(46);
end;
Expect(_rparenSym);

NextInstruction(currentscript,  instruction_temp);


end;


procedure TAdventureScript.Parse;
begin
  errDist := minErrDist;
GetScanner._Reset;
Get;
_AdventureScript;
end;  {Parse}

procedure TAdventureScript.InitSymSet;
begin
symSet[ 0, 0] := [EOFSYMB];
symSet[ 0, 1] := [];
symSet[ 0, 2] := [];
symSet[ 1, 0] := [identifierSym, numberSym, stringSym];
symSet[ 1, 1] := [_plusSym-16, _minusSym-16, _slashSym-16, _starSym-16];
symSet[ 1, 2] := [];
end; {InitSymSet}

end { AdventureScript }.    
