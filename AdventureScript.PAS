unit AdventureScript;

{ ==============================================================================
  AdventureScript
  1.0.0.0
  Date of Generation: 9.2.2020 16.57

  This unit was generated by Coco/R for Delphi (www.tetzel.com)  Any code in
  this file that you edit manually will be over-written when the file is
  regenerated.
  ============================================================================== }

interface

uses Variants, SysUtils, AdventureScriptCompilerUtils, Classes, CocoBase;

const
  maxT = 43;

type
  SymbolSet = array [0 .. maxT div setsize] of TBitSet;

  EAdventureScript = class(Exception);
  TAdventureScript = class;

  TAdventureScriptScanner = class(TCocoRScanner)
  private
    FOwner: TAdventureScript;
    fLastCommentList: TCommentList;
    procedure CheckLiteral(var Sym: integer);
    function Equal(s: ansistring): boolean;
    function Comment: boolean;
  protected
    procedure NextCh; override;
  public
    constructor Create;
    destructor Destroy; override;

    procedure Get(var Sym: integer); override;
    // Gets next symbol from source file

    property CurrentSymbol;
    property NextSymbol;
    property OnStatusUpdate;
    property Owner: TAdventureScript read FOwner write FOwner;
    property ScannerError;
    property SrcStream;
  end; { TAdventureScriptScanner }

  TAdventureScript = class(TCocoRGrammar)
  private
    { strictly internal variables }
    symSet: array [0 .. 2] of SymbolSet; // symSet[0] = allSyncSyms
    fInternalGrammarComment: TCommentEvent;

    function GetBuildDate: TDateTime;
    function GetVersion: ansistring;
    function GetVersionStr: ansistring;
    procedure SetVersion(const Value: ansistring);
    function _In(var s: SymbolSet; x: integer): boolean;
    procedure InitSymSet;

    { Production methods }
    procedure _AdventureScript;
    procedure _GlobalVars;
    procedure _VariableDefinition;
    procedure _FuncDefinition;
    procedure _ForLoop;
    procedure _SwitchStatement;
    procedure _CaseLabel;
    procedure _SetVar;
    procedure _RegularExp;
    procedure _Expression;
    procedure _RegularData;
    procedure _RegularCommand;
    procedure _RandomChance;
    procedure _Param;
    procedure _FunctionParam;
    procedure _Command;
    procedure _IfStatement;
    procedure _Conditions;
    procedure _Condition;

  private
    fOutputStream: TMemoryStream;
    fSubSelectDepth: integer;
    fInNaturalJoin: boolean;

    procedure Init;
    procedure Final;

    property OutputStream: TMemoryStream read fOutputStream write fOutputStream;

  protected
    { Protected Declarations }
    procedure Get; override;
    property InternalGrammarComment: TCommentEvent read fInternalGrammarComment
      write fInternalGrammarComment;
  public
    { Public Declarations }
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;

    function ErrorStr(const ErrorCode: integer; const Data: ansistring)
      : ansistring; override;
    procedure Execute;
    function GetScanner: TAdventureScriptScanner;
    procedure Parse;

    property ErrorList;
    property ListStream;
    property SourceStream;
    property Successful;
    property BuildDate: TDateTime read GetBuildDate;
    property VersionStr: ansistring read GetVersionStr;

  published
    { Published Declarations }
    property AfterGet;
    property AfterParse;
    property AfterGenList;
    property BeforeGenList;
    property BeforeParse;
    property ClearSourceStream;
    property GenListWhen;
    property SourceFileName;
    property Version: ansistring read GetVersion write SetVersion;

    property OnCustomError;
    property OnError;
    property OnFailure;
    property OnStatusUpdate;
    property OnSuccess;
  end; { TAdventureScript }

implementation

var
  name_temp: string;
  return_type_temp: integer;
  instruction_temp: instruction;

const

  EOFSYMB = 0;
  identifierSym = 1;
  numberSym = 2;
  hexnumberSym = 3;
  _stringSym = 4;
  _charSym = 5;
  _librarySym = 6;
  _lparenSym = 7;
  _equal_equalSym = 8;
  _bang_equalSym = 9;
  _greaterSym = 10;
  _greater_equalSym = 11;
  _less_equalSym = 12;
  _lessSym = 13;
  _rparenSym = 14;
  _and_andSym = 15;
  _barSym = 16;
  IFSym = 17;
  _lbraceSym = 18;
  _rbraceSym = 19;
  ELSESym = 20;
  INTSym = 21;
  STRSym = 22;
  RANDOMCHANCESym = 23;
  SETSym = 24;
  TARGET_underscoreNODESym = 25;
  _commaSym = 26;
  _plusSym = 27;
  _minusSym = 28;
  _slashSym = 29;
  _starSym = 30;
  SETVARSym = 31;
  _dollarSym = 32;
  _equalSym = 33;
  _colonSym = 34;
  SWITCHSym = 35;
  FORSym = 36;
  TOSym = 37;
  _semicolonSym = 38;
  VOIDSym = 39;
  VARSym = 40;
  GLOBALVARIABLESSym = 41;
  FUNCTIONSSym = 42;
  NOSYMB = 43;
  _noSym = NOSYMB; { error token code }

  { --------------------------------------------------------------------------- }
  { Arbitrary Code from ATG file }
const
  PadLen = 20;

function PadR(s: ansistring; Ch: char; L: integer): ansistring;
var
  i: integer;
begin
  for i := 1 to L - (Length(s)) do
    s := s + Ch;
  Result := s;
end;

procedure TAdventureScript.Init;
begin
  OutputStream.Clear;

end;

procedure TAdventureScript.Final;
begin
  OutputStream.Position := 0;
  OutputStream.SaveToStream(ListStream);
  OutputStream.Clear;
end;

function parse_string(zstr: string): string;
var
  t: integer;
var
  temp: string;
var
  len: integer;
begin;
  len := 0;
  temp := '';
  // writeln ('Parsing string: ',zstr);
  t := pos('"', zstr) + 1;
  len := Length(zstr);
  while (zstr[t] <> '"') do
  begin;
    // writeln (zstr[t]);
    if (zstr[t] = '\') and (zstr[t + 1] = '"') then
    begin;
      temp := temp + '"';
      Inc(t, 1);
    end
    else if (zstr[t] = '\') and (zstr[t + 1] = '\') then
    begin;
      temp := temp + '\';
      Inc(t, 1);
    end
    else if (zstr[t] = '\') and (zstr[t + 1] = 't') then
    begin;
      temp := temp + #9;
      Inc(t, 1);
    end
    else if (zstr[t] = '\') and (zstr[t + 1] = 'n') then
    begin;
      temp := temp + #13#10;
      Inc(t, 1);
    end
    else

      temp := temp + zstr[t];

    Inc(t);
  end;
  Result := temp;
end;

(* End of Arbitrary Code *)

{ --------------------------------------------------------------------------- }
{ ---- implementation for TAdventureScriptScanner ---- }

procedure TAdventureScriptScanner.NextCh;
{ Return global variable ch }
begin
  LastInputCh := CurrInputCh;
  BufferPosition := BufferPosition + 1;
  SrcStream.Seek(BufferPosition, soFromBeginning);
  CurrInputCh := CurrentCh(BufferPosition);
  if (CurrInputCh = _EL) OR ((CurrInputCh = _LF) AND (LastInputCh <> _EL)) then
  begin
    CurrLine := CurrLine + 1;
    if Assigned(OnStatusUpdate) then
      OnStatusUpdate(Owner, cstLineNum, '', CurrLine);
    StartOfLine := BufferPosition;
  end
end; { NextCh }

function TAdventureScriptScanner.Comment: boolean;
var
  level: integer;
  CommentColumn: integer;
  CommentLine: integer;
  startLine: integer;
  oldLineStart: longint;
  CommentStr: ansistring;
begin
  level := 1;
  startLine := CurrLine;
  oldLineStart := StartOfLine;
  CommentStr := CharAt(BufferPosition);
  CommentColumn := BufferPosition - StartOfLine - 1;
  CommentLine := CurrLine;
  Result := false;
  if (CurrInputCh = '/') then
  begin
    NextCh;
    CommentStr := CommentStr + CharAt(BufferPosition);
    if (CurrInputCh = '/') then
    begin
      NextCh;
      CommentStr := CommentStr + CharAt(BufferPosition);
      while true do
      begin
        if (CurrInputCh = CHR(10)) then
        begin
          level := level - 1;
          NumEOLInComment := CurrLine - startLine;
          NextCh;
          CommentStr := CommentStr + CharAt(BufferPosition);
          if level = 0 then
          begin
            Result := true;
            fLastCommentList.Add(CommentStr, CommentLine, CommentColumn);
            Exit;
          end;
        end
        else if CurrInputCh = _EF then
        begin
          Result := false;
          fLastCommentList.Add(CommentStr, CommentLine, CommentColumn);
          Exit;
        end
        else
        begin
          NextCh;
          CommentStr := CommentStr + CharAt(BufferPosition);
        end;
      end; { WHILE TRUE }
    end
    else
    begin
      if (CurrInputCh = _CR) OR (CurrInputCh = _LF) then
      begin
        CurrLine := CurrLine - 1;
        StartOfLine := oldLineStart
      end;
      BufferPosition := BufferPosition - 1;
      CurrInputCh := LastInputCh;
      Result := false;
    end;
  end;
  Result := false;
  if (CurrInputCh = '/') then
  begin
    NextCh;
    CommentStr := CommentStr + CharAt(BufferPosition);
    if (CurrInputCh = '*') then
    begin
      NextCh;
      CommentStr := CommentStr + CharAt(BufferPosition);
      while true do
      begin
        if (CurrInputCh = '*') then
        begin
          NextCh;
          CommentStr := CommentStr + CharAt(BufferPosition);
          if (CurrInputCh = '/') then
          begin
            level := level - 1;
            NextCh;
            CommentStr := CommentStr + CharAt(BufferPosition);
            if level = 0 then
            begin
              Result := true;
              fLastCommentList.Add(CommentStr, CommentLine, CommentColumn);
              Exit;
            end
          end
        end
        else if CurrInputCh = _EF then
        begin
          Result := false;
          fLastCommentList.Add(CommentStr, CommentLine, CommentColumn);
          Exit;
        end
        else
        begin
          NextCh;
          CommentStr := CommentStr + CharAt(BufferPosition);
        end;
      end; { WHILE TRUE }
    end
    else
    begin
      if (CurrInputCh = _CR) OR (CurrInputCh = _LF) then
      begin
        CurrLine := CurrLine - 1;
        StartOfLine := oldLineStart
      end;
      BufferPosition := BufferPosition - 1;
      CurrInputCh := LastInputCh;
      Result := false;
    end;
  end;
end; { Comment }

function TAdventureScriptScanner.Equal(s: ansistring): boolean;
var
  i: integer;
  q: longint;
begin
  if NextSymbol.len <> Length(s) then
  begin
    Result := false;
    Exit
  end;
  i := 1;
  q := bpCurrToken;
  while i <= NextSymbol.len do
  begin
    if CurrentCh(q) <> s[i] then
    begin
      Result := false;
      Exit;
    end;
    Inc(i);
    Inc(q);
  end;
  Result := true
end; { Equal }

procedure TAdventureScriptScanner.CheckLiteral(var Sym: integer);
begin
  case CurrentCh(bpCurrToken) of
    'E':
      if Equal('ELSE') then
      begin
        Sym := ELSESym;
      end;

    'F':
      if Equal('FOR') then
      begin
        Sym := FORSym;
      end
      else if Equal('FUNCTIONS') then
      begin
        Sym := FUNCTIONSSym;
      end;

    'G':
      if Equal('GLOBALVARIABLES') then
      begin
        Sym := GLOBALVARIABLESSym;
      end;

    'I':
      if Equal('IF') then
      begin
        Sym := IFSym;
      end
      else if Equal('INT') then
      begin
        Sym := INTSym;
      end;

    'R':
      if Equal('RANDOMCHANCE') then
      begin
        Sym := RANDOMCHANCESym;
      end;

    'S':
      if Equal('SET') then
      begin
        Sym := SETSym;
      end
      else if Equal('SETVAR') then
      begin
        Sym := SETVARSym;
      end
      else if Equal('STR') then
      begin
        Sym := STRSym;
      end
      else if Equal('SWITCH') then
      begin
        Sym := SWITCHSym;
      end;

    'T':
      if Equal('TARGET_NODE') then
      begin
        Sym := TARGET_underscoreNODESym;
      end
      else if Equal('TO') then
      begin
        Sym := TOSym;
      end;

    'V':
      if Equal('VAR') then
      begin
        Sym := VARSym;
      end
      else if Equal('VOID') then
      begin
        Sym := VOIDSym;
      end;

  else
    begin
    end
  end
end; { CheckLiteral }

procedure TAdventureScriptScanner.Get(var Sym: integer);
var
  state: integer;
begin { Get }
  while (CurrInputCh = ' ') OR
    ((CurrInputCh >= CHR(1)) AND (CurrInputCh <= ' ')) do
    NextCh;
  if ((CurrInputCh = '/') OR (CurrInputCh = '/')) AND Comment then
  begin
    Get(Sym);
    Exit;
  end;

  CurrentSymbol.Assign(NextSymbol);

  NextSymbol.pos := BufferPosition;
  NextSymbol.Col := BufferPosition - StartOfLine;
  NextSymbol.Line := CurrLine;
  NextSymbol.len := 0;

  ContextLen := 0;
  state := StartState[ORD(CurrInputCh)];
  bpCurrToken := BufferPosition;
  while true do
  begin
    NextCh;
    NextSymbol.len := NextSymbol.len + 1;
    if BufferPosition > SrcStream.Size then
    begin
      Sym := EOFSYMB;
      CurrInputCh := _EF;
      BufferPosition := BufferPosition - 1;
      Exit
    end;
    case state of
      1:
        if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
          (CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR (CurrInputCh = '_'))
        then
        begin

        end
        else
        begin
          Sym := identifierSym;
          CheckLiteral(Sym);
          Exit;
        end;
      2:
        if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
        begin

        end
        else if ((CurrInputCh = 'L') OR (CurrInputCh = 'U')) then
        begin
          state := 15;
        end
        else if (CurrInputCh = '.') then
        begin
          state := 3;
        end
        else
        begin
          Sym := numberSym;
          Exit;
        end;
      3:
        if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
        begin

        end
        else if ((CurrInputCh = 'L') OR (CurrInputCh = 'U')) then
        begin
          state := 15;
        end
        else
        begin
          Sym := numberSym;
          Exit;
        end;
      4:
        if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
          (CurrInputCh >= 'A') AND (CurrInputCh <= 'F')) then
        begin
          state := 5;
        end
        else
        begin
          Sym := _noSym;
          Exit;
        end;
      5:
        if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
          (CurrInputCh >= 'A') AND (CurrInputCh <= 'F')) then
        begin

        end
        else if ((CurrInputCh = 'L') OR (CurrInputCh = 'U')) then
        begin
          state := 16;
        end
        else
        begin
          Sym := hexnumberSym;
          Exit;
        end;
      6:
        if ((CurrInputCh >= ' ') AND (CurrInputCh <= '!') OR
          (CurrInputCh >= '#')) then
        begin

        end
        else if (CurrInputCh = '"') then
        begin
          state := 7;
        end
        else
        begin
          Sym := _noSym;
          Exit;
        end;
      7:
        begin
          Sym := _stringSym;
          Exit;
        end;
      8:
        if ((CurrInputCh >= ' ') AND (CurrInputCh <= '&') OR
          (CurrInputCh >= '(') AND (CurrInputCh <= '[') OR (CurrInputCh >= ']'))
        then
        begin
          state := 9;
        end
        else if (CurrInputCh = '\') then
        begin
          state := 17;
        end
        else
        begin
          Sym := _noSym;
          Exit;
        end;
      9:
        if (CurrInputCh = CHR(39)) then
        begin
          state := 10;
        end
        else
        begin
          Sym := _noSym;
          Exit;
        end;
      10:
        begin
          Sym := _charSym;
          Exit;
        end;
      11:
        if ((CurrInputCh = '.') OR (CurrInputCh >= '0') AND (CurrInputCh <= ':')
          OR (CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
          (CurrInputCh = '\')) then
        begin
          state := 12;
        end
        else if (CurrInputCh = '=') then
        begin
          state := 25;
        end
        else
        begin
          Sym := _lessSym;
          Exit;
        end;
      12:
        if ((CurrInputCh = '.') OR (CurrInputCh >= '0') AND (CurrInputCh <= ':')
          OR (CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
          (CurrInputCh = '\')) then
        begin

        end
        else if (CurrInputCh = '>') then
        begin
          state := 13;
        end
        else
        begin
          Sym := _noSym;
          Exit;
        end;
      13:
        begin
          Sym := _librarySym;
          Exit;
        end;
      14:
        if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
        begin
          state := 2;
        end
        else if ((CurrInputCh = 'L') OR (CurrInputCh = 'U')) then
        begin
          state := 15;
        end
        else if (CurrInputCh = '.') then
        begin
          state := 3;
        end
        else if (CurrInputCh = 'X') then
        begin
          state := 4;
        end
        else
        begin
          Sym := numberSym;
          Exit;
        end;
      15:
        begin
          Sym := numberSym;
          Exit;
        end;
      16:
        begin
          Sym := hexnumberSym;
          Exit;
        end;
      17:
        if ((CurrInputCh >= ' ') AND (CurrInputCh <= '&') OR
          (CurrInputCh >= '(')) then
        begin
          state := 9;
        end
        else if (CurrInputCh = CHR(39)) then
        begin
          state := 10;
        end
        else
        begin
          Sym := _noSym;
          Exit;
        end;
      18:
        begin
          Sym := _lparenSym;
          Exit;
        end;
      19:
        if (CurrInputCh = '=') then
        begin
          state := 20;
        end
        else
        begin
          Sym := _equalSym;
          Exit;
        end;
      20:
        begin
          Sym := _equal_equalSym;
          Exit;
        end;
      21:
        if (CurrInputCh = '=') then
        begin
          state := 22;
        end
        else
        begin
          Sym := _noSym;
          Exit;
        end;
      22:
        begin
          Sym := _bang_equalSym;
          Exit;
        end;
      23:
        if (CurrInputCh = '=') then
        begin
          state := 24;
        end
        else
        begin
          Sym := _greaterSym;
          Exit;
        end;
      24:
        begin
          Sym := _greater_equalSym;
          Exit;
        end;
      25:
        begin
          Sym := _less_equalSym;
          Exit;
        end;
      26:
        begin
          Sym := _rparenSym;
          Exit;
        end;
      27:
        if (CurrInputCh = '&') then
        begin
          state := 28;
        end
        else
        begin
          Sym := _noSym;
          Exit;
        end;
      28:
        begin
          Sym := _and_andSym;
          Exit;
        end;
      29:
        begin
          Sym := _barSym;
          Exit;
        end;
      30:
        begin
          Sym := _lbraceSym;
          Exit;
        end;
      31:
        begin
          Sym := _rbraceSym;
          Exit;
        end;
      32:
        begin
          Sym := _commaSym;
          Exit;
        end;
      33:
        begin
          Sym := _plusSym;
          Exit;
        end;
      34:
        begin
          Sym := _minusSym;
          Exit;
        end;
      35:
        begin
          Sym := _slashSym;
          Exit;
        end;
      36:
        begin
          Sym := _starSym;
          Exit;
        end;
      37:
        begin
          Sym := _dollarSym;
          Exit;
        end;
      38:
        begin
          Sym := _colonSym;
          Exit;
        end;
      39:
        begin
          Sym := _semicolonSym;
          Exit;
        end;
      40:
        begin
          Sym := EOFSYMB;
          CurrInputCh := #0;
          BufferPosition := BufferPosition - 1;
          Exit
        end;
    else
      begin
        Sym := _noSym;
        Exit; // NextCh already done
      end;
    end;
  end;
end; { Get }

constructor TAdventureScriptScanner.Create;
begin
  inherited;
  fLastCommentList := TCommentList.Create;
  CurrentCh := CapChAt;
  fStartState[0] := 40;
  fStartState[1] := 41;
  fStartState[2] := 41;
  fStartState[3] := 41;
  fStartState[4] := 41;
  fStartState[5] := 41;
  fStartState[6] := 41;
  fStartState[7] := 41;
  fStartState[8] := 41;
  fStartState[9] := 41;
  fStartState[10] := 41;
  fStartState[11] := 41;
  fStartState[12] := 41;
  fStartState[13] := 41;
  fStartState[14] := 41;
  fStartState[15] := 41;
  fStartState[16] := 41;
  fStartState[17] := 41;
  fStartState[18] := 41;
  fStartState[19] := 41;
  fStartState[20] := 41;
  fStartState[21] := 41;
  fStartState[22] := 41;
  fStartState[23] := 41;
  fStartState[24] := 41;
  fStartState[25] := 41;
  fStartState[26] := 41;
  fStartState[27] := 41;
  fStartState[28] := 41;
  fStartState[29] := 41;
  fStartState[30] := 41;
  fStartState[31] := 41;
  fStartState[32] := 41;
  fStartState[33] := 21;
  fStartState[34] := 6;
  fStartState[35] := 41;
  fStartState[36] := 37;
  fStartState[37] := 41;
  fStartState[38] := 27;
  fStartState[39] := 8;
  fStartState[40] := 18;
  fStartState[41] := 26;
  fStartState[42] := 36;
  fStartState[43] := 33;
  fStartState[44] := 32;
  fStartState[45] := 34;
  fStartState[46] := 41;
  fStartState[47] := 35;
  fStartState[48] := 14;
  fStartState[49] := 2;
  fStartState[50] := 2;
  fStartState[51] := 2;
  fStartState[52] := 2;
  fStartState[53] := 2;
  fStartState[54] := 2;
  fStartState[55] := 2;
  fStartState[56] := 2;
  fStartState[57] := 2;
  fStartState[58] := 38;
  fStartState[59] := 39;
  fStartState[60] := 11;
  fStartState[61] := 19;
  fStartState[62] := 23;
  fStartState[63] := 41;
  fStartState[64] := 41;
  fStartState[65] := 1;
  fStartState[66] := 1;
  fStartState[67] := 1;
  fStartState[68] := 1;
  fStartState[69] := 1;
  fStartState[70] := 1;
  fStartState[71] := 1;
  fStartState[72] := 1;
  fStartState[73] := 1;
  fStartState[74] := 1;
  fStartState[75] := 1;
  fStartState[76] := 1;
  fStartState[77] := 1;
  fStartState[78] := 1;
  fStartState[79] := 1;
  fStartState[80] := 1;
  fStartState[81] := 1;
  fStartState[82] := 1;
  fStartState[83] := 1;
  fStartState[84] := 1;
  fStartState[85] := 1;
  fStartState[86] := 1;
  fStartState[87] := 1;
  fStartState[88] := 1;
  fStartState[89] := 1;
  fStartState[90] := 1;
  fStartState[91] := 41;
  fStartState[92] := 41;
  fStartState[93] := 41;
  fStartState[94] := 41;
  fStartState[95] := 1;
  fStartState[96] := 41;
  fStartState[97] := 41;
  fStartState[98] := 41;
  fStartState[99] := 41;
  fStartState[100] := 41;
  fStartState[101] := 41;
  fStartState[102] := 41;
  fStartState[103] := 41;
  fStartState[104] := 41;
  fStartState[105] := 41;
  fStartState[106] := 41;
  fStartState[107] := 41;
  fStartState[108] := 41;
  fStartState[109] := 41;
  fStartState[110] := 41;
  fStartState[111] := 41;
  fStartState[112] := 41;
  fStartState[113] := 41;
  fStartState[114] := 41;
  fStartState[115] := 41;
  fStartState[116] := 41;
  fStartState[117] := 41;
  fStartState[118] := 41;
  fStartState[119] := 41;
  fStartState[120] := 41;
  fStartState[121] := 41;
  fStartState[122] := 41;
  fStartState[123] := 30;
  fStartState[124] := 29;
  fStartState[125] := 31;
  fStartState[126] := 41;
  fStartState[127] := 41;
  fStartState[128] := 41;
  fStartState[129] := 41;
  fStartState[130] := 41;
  fStartState[131] := 41;
  fStartState[132] := 41;
  fStartState[133] := 41;
  fStartState[134] := 41;
  fStartState[135] := 41;
  fStartState[136] := 41;
  fStartState[137] := 41;
  fStartState[138] := 41;
  fStartState[139] := 41;
  fStartState[140] := 41;
  fStartState[141] := 41;
  fStartState[142] := 41;
  fStartState[143] := 41;
  fStartState[144] := 41;
  fStartState[145] := 41;
  fStartState[146] := 41;
  fStartState[147] := 41;
  fStartState[148] := 41;
  fStartState[149] := 41;
  fStartState[150] := 41;
  fStartState[151] := 41;
  fStartState[152] := 41;
  fStartState[153] := 41;
  fStartState[154] := 41;
  fStartState[155] := 41;
  fStartState[156] := 41;
  fStartState[157] := 41;
  fStartState[158] := 41;
  fStartState[159] := 41;
  fStartState[160] := 41;
  fStartState[161] := 41;
  fStartState[162] := 41;
  fStartState[163] := 41;
  fStartState[164] := 41;
  fStartState[165] := 41;
  fStartState[166] := 41;
  fStartState[167] := 41;
  fStartState[168] := 41;
  fStartState[169] := 41;
  fStartState[170] := 41;
  fStartState[171] := 41;
  fStartState[172] := 41;
  fStartState[173] := 41;
  fStartState[174] := 41;
  fStartState[175] := 41;
  fStartState[176] := 41;
  fStartState[177] := 41;
  fStartState[178] := 41;
  fStartState[179] := 41;
  fStartState[180] := 41;
  fStartState[181] := 41;
  fStartState[182] := 41;
  fStartState[183] := 41;
  fStartState[184] := 41;
  fStartState[185] := 41;
  fStartState[186] := 41;
  fStartState[187] := 41;
  fStartState[188] := 41;
  fStartState[189] := 41;
  fStartState[190] := 41;
  fStartState[191] := 41;
  fStartState[192] := 41;
  fStartState[193] := 41;
  fStartState[194] := 41;
  fStartState[195] := 41;
  fStartState[196] := 41;
  fStartState[197] := 41;
  fStartState[198] := 41;
  fStartState[199] := 41;
  fStartState[200] := 41;
  fStartState[201] := 41;
  fStartState[202] := 41;
  fStartState[203] := 41;
  fStartState[204] := 41;
  fStartState[205] := 41;
  fStartState[206] := 41;
  fStartState[207] := 41;
  fStartState[208] := 41;
  fStartState[209] := 41;
  fStartState[210] := 41;
  fStartState[211] := 41;
  fStartState[212] := 41;
  fStartState[213] := 41;
  fStartState[214] := 41;
  fStartState[215] := 41;
  fStartState[216] := 41;
  fStartState[217] := 41;
  fStartState[218] := 41;
  fStartState[219] := 41;
  fStartState[220] := 41;
  fStartState[221] := 41;
  fStartState[222] := 41;
  fStartState[223] := 41;
  fStartState[224] := 41;
  fStartState[225] := 41;
  fStartState[226] := 41;
  fStartState[227] := 41;
  fStartState[228] := 41;
  fStartState[229] := 41;
  fStartState[230] := 41;
  fStartState[231] := 41;
  fStartState[232] := 41;
  fStartState[233] := 41;
  fStartState[234] := 41;
  fStartState[235] := 41;
  fStartState[236] := 41;
  fStartState[237] := 41;
  fStartState[238] := 41;
  fStartState[239] := 41;
  fStartState[240] := 41;
  fStartState[241] := 41;
  fStartState[242] := 41;
  fStartState[243] := 41;
  fStartState[244] := 41;
  fStartState[245] := 41;
  fStartState[246] := 41;
  fStartState[247] := 41;
  fStartState[248] := 41;
  fStartState[249] := 41;
  fStartState[250] := 41;
  fStartState[251] := 41;
  fStartState[252] := 41;
  fStartState[253] := 41;
  fStartState[254] := 41;
  fStartState[255] := 41;
end; { Create }

destructor TAdventureScriptScanner.Destroy;
begin
  if Assigned(fLastCommentList) then
  begin
    fLastCommentList.Free;
    fLastCommentList := NIL;
  end;
  inherited;
end;

{ --------------------------------------------------------------------------- }
{ ---- implementation for TAdventureScript ---- }

constructor TAdventureScript.Create(AOwner: TComponent);
begin
  inherited;
  Scanner := TAdventureScriptScanner.Create;
  GetScanner.Owner := self;
  fOutputStream := TMemoryStream.Create;

  InitSymSet;
end; { Create }

destructor TAdventureScript.Destroy;
begin
  Scanner.Free;
  fOutputStream.Free;

  inherited;
end; { Destroy }

function TAdventureScript.ErrorStr(const ErrorCode: integer;
  const Data: ansistring): ansistring;
begin
  case ErrorCode of
    0:
      Result := 'EOF expected';
    1:
      Result := 'identifier expected';
    2:
      Result := 'number expected';
    3:
      Result := 'hexnumber expected';
    4:
      Result := '_string expected';
    5:
      Result := '_char expected';
    6:
      Result := '_library expected';
    7:
      Result := '"(" expected';
    8:
      Result := '"==" expected';
    9:
      Result := '"!=" expected';
    10:
      Result := '">" expected';
    11:
      Result := '">=" expected';
    12:
      Result := '"<=" expected';
    13:
      Result := '"<" expected';
    14:
      Result := '")" expected';
    15:
      Result := '"&&" expected';
    16:
      Result := '"|" expected';
    17:
      Result := '"IF" expected';
    18:
      Result := '"{" expected';
    19:
      Result := '"}" expected';
    20:
      Result := '"ELSE" expected';
    21:
      Result := '"INT" expected';
    22:
      Result := '"STR" expected';
    23:
      Result := '"RANDOMCHANCE" expected';
    24:
      Result := '"SET" expected';
    25:
      Result := '"TARGET_NODE" expected';
    26:
      Result := '"," expected';
    27:
      Result := '"+" expected';
    28:
      Result := '"-" expected';
    29:
      Result := '"/" expected';
    30:
      Result := '"*" expected';
    31:
      Result := '"SETVAR" expected';
    32:
      Result := '"$" expected';
    33:
      Result := '"=" expected';
    34:
      Result := '":" expected';
    35:
      Result := '"SWITCH" expected';
    36:
      Result := '"FOR" expected';
    37:
      Result := '"TO" expected';
    38:
      Result := '";" expected';
    39:
      Result := '"VOID" expected';
    40:
      Result := '"VAR" expected';
    41:
      Result := '"GLOBALVARIABLES" expected';
    42:
      Result := '"FUNCTIONS" expected';
    43:
      Result := 'not expected';
    44:
      Result := 'invalid VariableDefinition';
    45:
      Result := 'invalid FuncDefinition';
    46:
      Result := 'invalid ForLoop';
    47:
      Result := 'invalid ForLoop';
    48:
      Result := 'invalid CaseLabel';
    49:
      Result := 'invalid SetVar';
    50:
      Result := 'invalid Expression';
    51:
      Result := 'invalid RegularData';
    52:
      Result := 'invalid Param';
    53:
      Result := 'invalid FunctionParam';
    54:
      Result := 'invalid FunctionParam';
    55:
      Result := 'invalid Command';
    56:
      Result := 'invalid Condition';
    57:
      Result := 'invalid Condition';

  else
    if Assigned(OnCustomError) then
      Result := OnCustomError(self, ErrorCode, Data)
    else
    begin
      Result := 'Error: ' + IntToStr(ErrorCode);
      if Trim(Data) > '' then
        Result := Result + ' (' + Data + ')';
    end;
  end; { case nr }
end; { ErrorStr }

procedure TAdventureScript.Execute;
begin
  ClearErrors;
  ListStream.Clear;
  Extra := 1;

  { if there is a file name then load the file }
  if Trim(SourceFileName) <> '' then
  begin
    GetScanner.SrcStream.Clear;
    GetScanner.SrcStream.LoadFromFile(SourceFileName);
  end;

  { install error reporting procedure }
  GetScanner.ScannerError := StoreError;

  { instigate the compilation }
  DoBeforeParse;
  Parse;
  DoAfterParse;

  { generate the source listing to the ListStream }
  if (GenListWhen = glAlways) OR
    ((GenListWhen = glOnError) AND (ErrorList.Count > 0)) then
    GenerateListing;
  if ClearSourceStream then
    GetScanner.SrcStream.Clear;
  ListStream.Position := 0; // goto the beginning of the stream
  if Successful AND Assigned(OnSuccess) then
    OnSuccess(self);
  if (NOT Successful) AND Assigned(OnFailure) then
    OnFailure(self, ErrorList.Count);
end; { Execute }

procedure TAdventureScript.Get;
begin
  repeat

    if GetScanner.fLastCommentList.Count > 0 then
    begin
      if Assigned(fInternalGrammarComment) then
        fInternalGrammarComment(self, GetScanner.fLastCommentList);
      GetScanner.fLastCommentList.Clear;
    end;

    GetScanner.Get(fCurrentInputSymbol);
    if fCurrentInputSymbol <= maxT then
      errDist := errDist + 1
    else
    begin
    end;
  until fCurrentInputSymbol <= maxT;
  if Assigned(AfterGet) then
    AfterGet(self, fCurrentInputSymbol);
end; { Get }

function TAdventureScript.GetScanner: TAdventureScriptScanner;
begin
  Result := Scanner AS TAdventureScriptScanner;
end; { GetScanner }

function TAdventureScript._In(var s: SymbolSet; x: integer): boolean;
begin
  _In := x mod setsize in s[x div setsize];
end; { _In }

procedure TAdventureScript._AdventureScript;
begin
  if (fCurrentInputSymbol = GLOBALVARIABLESSym) then
  begin
    Get;
    Expect(_colonSym);
    _GlobalVars;
  end;
  Expect(FUNCTIONSSym);
  Expect(_colonSym);
  _FuncDefinition;
  while (fCurrentInputSymbol = INTSym) OR (fCurrentInputSymbol = STRSym) OR
    (fCurrentInputSymbol = VOIDSym) do
  begin
    _FuncDefinition;
  end;
end;

procedure TAdventureScript._GlobalVars;
begin
  Expect(VARSym);
  _VariableDefinition;
  while (fCurrentInputSymbol = identifierSym) do
  begin
    _VariableDefinition;
  end;
end;

procedure TAdventureScript._VariableDefinition;
begin
  Expect(identifierSym);

  name_temp := lexstring;
  AddVariable(CurrentScript, name_temp);

  if (fCurrentInputSymbol = _equalSym) then
  begin
    Get;
    if (fCurrentInputSymbol = _stringSym) then
    begin
      Get;

      SetVariableValue(CurrentScript, name_temp, parse_string(lexstring));

    end
    else if (fCurrentInputSymbol = numberSym) then
    begin
      Get;

      SetVariableValue(CurrentScript, name_temp, strtoint(lexstring));

    end
    else if (fCurrentInputSymbol = hexnumberSym) then
    begin
      Get;

      SetVariableValue(CurrentScript, name_temp, strtoint(lexstring));

    end
    else
    begin
      SynError(44);
    end;
  end;
  Expect(_semicolonSym);
end;

procedure TAdventureScript._FuncDefinition;
begin
  if (fCurrentInputSymbol = INTSym) then
  begin
    Get;

    return_type_temp := RETURN_TYPE_INTEGER;

  end
  else if (fCurrentInputSymbol = VOIDSym) then
  begin
    Get;

    return_type_temp := RETURN_TYPE_VOID;

  end
  else if (fCurrentInputSymbol = STRSym) then
  begin
    Get;

    return_type_temp := RETURN_TYPE_STRING;

  end
  else
  begin
    SynError(45);
  end;
  Expect(identifierSym);

  name_temp := lexstring;
  instruction_temp := AddInstruction(CurrentScript, OP_FUNCTIONDEF);
  AddParam(instruction_temp, name_temp, DATA_TYPE_FUNCTION_NAME);
  AddParam(instruction_temp, return_type_temp, DATA_TYPE_RETURN_TYPE);
  NextInstruction(CurrentScript, instruction_temp);

  Expect(_lparenSym);
  if (fCurrentInputSymbol = INTSym) OR (fCurrentInputSymbol = STRSym) then
  begin
    _FunctionParam;
    while (fCurrentInputSymbol = _commaSym) do
    begin
      Get;
      _FunctionParam;
    end;
  end;
  Expect(_rparenSym);
  Expect(_lbraceSym);

  instruction_temp := AddInstruction(CurrentScript, OP_FUNCTIONBEGIN);
  NextInstruction(CurrentScript, instruction_temp);

  while _In(symSet[1], fCurrentInputSymbol) do
  begin
    if (fCurrentInputSymbol = identifierSym) OR
      (fCurrentInputSymbol = RANDOMCHANCESym) OR
      (fCurrentInputSymbol = SETVARSym) then
    begin
      _Command;
    end
    else if (fCurrentInputSymbol = IFSym) then
    begin
      _IfStatement;
    end
    else if (fCurrentInputSymbol = SWITCHSym) then
    begin
      _SwitchStatement;
    end
    else
    begin
      _ForLoop;
    end;
  end;
  Expect(_rbraceSym);

  instruction_temp := AddInstruction(CurrentScript, OP_FUNCTIONEND);
  NextInstruction(CurrentScript, instruction_temp);

end;

procedure TAdventureScript._ForLoop;
begin
  Expect(FORSym);

  instruction_temp := AddInstruction(CurrentScript, OP_FOR_LOOP);

  Expect(identifierSym);
  AddParam(instruction_temp, lexstring, DATA_TYPE_FOR_VARIABLE);

  Expect(_equalSym);
  if (fCurrentInputSymbol = numberSym) then
  begin
    Get;
    AddParam(instruction_temp, strtoint(lexstring), DATA_TYPE_FOR_START);
  end
  else if (fCurrentInputSymbol = identifierSym) then
  begin
    Get;
    AddParam(instruction_temp, lexstring, DATA_TYPE_FOR_START);
  end
  else
  begin
    SynError(46);
  end;
  Expect(TOSym);
  if (fCurrentInputSymbol = numberSym) then
  begin
    Get;
    AddParam(instruction_temp, strtoint(lexstring), DATA_TYPE_FOR_STOP);
  end
  else if (fCurrentInputSymbol = identifierSym) then
  begin
    Get;
    AddParam(instruction_temp, lexstring, DATA_TYPE_FOR_STOP);
  end
  else
  begin
    SynError(47);
  end;
  NextInstruction(CurrentScript, instruction_temp);
  Expect(_lbraceSym);
  instruction_temp := AddInstruction(CurrentScript, OP_FOR_BEGIN);
  NextInstruction(CurrentScript, instruction_temp);

  _Command;
  while (fCurrentInputSymbol = identifierSym) OR
    (fCurrentInputSymbol = RANDOMCHANCESym) OR
    (fCurrentInputSymbol = SETVARSym) do
  begin
    _Command;
  end;
  Expect(_rbraceSym);
  instruction_temp := AddInstruction(CurrentScript, OP_FOR_END);
  NextInstruction(CurrentScript, instruction_temp);

end;

procedure TAdventureScript._SwitchStatement;
begin
  Expect(SWITCHSym);
  instruction_temp := AddInstruction(CurrentScript, OP_SWITCH_VAR);
  Expect(identifierSym);
  AddParam(instruction_temp, lexstring, DATA_TYPE_SWITCH_VAR);
  NextInstruction(CurrentScript, instruction_temp);
  Expect(_lbraceSym);
  instruction_temp := AddInstruction(CurrentScript, OP_SWITCH_BEGIN);
  NextInstruction(CurrentScript, instruction_temp);

  _CaseLabel;
  while (fCurrentInputSymbol = identifierSym) OR
    (fCurrentInputSymbol = numberSym) OR (fCurrentInputSymbol = _stringSym) do
  begin
    _CaseLabel;
  end;
  Expect(_rbraceSym);
  instruction_temp := AddInstruction(CurrentScript, OP_SWITCH_END);
  NextInstruction(CurrentScript, instruction_temp);

end;

procedure TAdventureScript._CaseLabel;
begin
  if (fCurrentInputSymbol = _stringSym) then
  begin
    Get;
    instruction_temp := AddInstruction(CurrentScript, OP_SWITCH_LABEL);
    AddParam(instruction_temp, parse_string(lexstring),
      DATA_TYPE_SWITCH_LABEL_DATA);
    NextInstruction(CurrentScript, instruction_temp);

  end
  else if (fCurrentInputSymbol = numberSym) then
  begin
    Get;
    instruction_temp := AddInstruction(CurrentScript, OP_SWITCH_LABEL);
    AddParam(instruction_temp, strtoint(lexstring),
      DATA_TYPE_SWITCH_LABEL_DATA);
    NextInstruction(CurrentScript, instruction_temp);

  end
  else if (fCurrentInputSymbol = identifierSym) then
  begin
    Get;

    instruction_temp := AddInstruction(CurrentScript, OP_SWITCH_LABEL);
    AddParam(instruction_temp, lexstring, DATA_TYPE_SWITCH_LABEL_DATA);
    NextInstruction(CurrentScript, instruction_temp);

  end
  else
  begin
    SynError(48);
  end;
  Expect(_colonSym);
  Expect(_lbraceSym);
  instruction_temp := AddInstruction(CurrentScript, OP_SWITCH_LABEL_CODE_BEGIN);
  NextInstruction(CurrentScript, instruction_temp);
  while (fCurrentInputSymbol = identifierSym) OR
    (fCurrentInputSymbol = RANDOMCHANCESym) OR
    (fCurrentInputSymbol = SETVARSym) do
  begin
    _Command;
  end;
  Expect(_rbraceSym);
  instruction_temp := AddInstruction(CurrentScript, OP_SWITCH_LABEL_CODE_END);
  NextInstruction(CurrentScript, instruction_temp);
end;

procedure TAdventureScript._SetVar;
begin
  Expect(SETVARSym);
  Expect(_dollarSym);
  Expect(identifierSym);

  instruction_temp := AddInstruction(CurrentScript, OP_BEGININSTRUCTION);
  NextInstruction(CurrentScript, instruction_temp);
  name_temp := lexstring;
  instruction_temp := AddInstruction(CurrentScript, OP_SETVAR);
  AddParam(instruction_temp, name_temp, DATA_TYPE_VAR_NAME);
  NextInstruction(CurrentScript, instruction_temp);

  if VariableExists(CurrentScript, name_temp) = false then
    AddVariable(CurrentScript, name_temp);

  Expect(_equalSym);
  if (fCurrentInputSymbol = identifierSym) then
  begin
    _RegularCommand;

    instruction_temp := AddInstruction(CurrentScript, OP_ENDINSTRUCTION);
    NextInstruction(CurrentScript, instruction_temp);

  end
  else if (fCurrentInputSymbol = identifierSym) OR
    (fCurrentInputSymbol = numberSym) OR (fCurrentInputSymbol = _stringSym) then
  begin
    _RegularExp;
  end
  else
  begin
    SynError(49);
  end;
end;

procedure TAdventureScript._RegularExp;
begin

  instruction_temp := AddInstruction(CurrentScript, OP_EXPRESSIONDATA);

  _RegularData;
  while _In(symSet[2], fCurrentInputSymbol) do
  begin
    _Expression;

    NextInstruction(CurrentScript, instruction_temp);

    instruction_temp := AddInstruction(CurrentScript, OP_EXPRESSIONDATA);

    _RegularData;
  end;
  instruction_temp := AddInstruction(CurrentScript, OP_ENDINSTRUCTION);
  NextInstruction(CurrentScript, instruction_temp);

end;

procedure TAdventureScript._Expression;
begin
  if (fCurrentInputSymbol = _plusSym) then
  begin
    Get;

    instruction_temp := AddInstruction(CurrentScript, OP_ADD);

  end
  else if (fCurrentInputSymbol = _minusSym) then
  begin
    Get;
  end
  else if (fCurrentInputSymbol = identifierSym) OR
    (fCurrentInputSymbol = numberSym) OR (fCurrentInputSymbol = _stringSym) then
  begin

    instruction_temp := AddInstruction(CurrentScript, OP_SUBTRACT);

  end
  else if (fCurrentInputSymbol = _slashSym) then
  begin
    Get;

    instruction_temp := AddInstruction(CurrentScript, OP_DIVIDE);

  end
  else if (fCurrentInputSymbol = _starSym) then
  begin
    Get;

    instruction_temp := AddInstruction(CurrentScript, OP_MULTIPLY);

  end
  else
  begin
    SynError(50);
  end;
end;

procedure TAdventureScript._RegularData;
begin
  if (fCurrentInputSymbol = identifierSym) then
  begin
    Get;

    AddParam(instruction_temp, lexstring, DATA_TYPE_REGULARDATA);
    NextInstruction(CurrentScript, instruction_temp);

  end
  else if (fCurrentInputSymbol = numberSym) then
  begin
    Get;

    AddParam(instruction_temp, VarAsType(strtoint(lexstring), VarInteger),
      DATA_TYPE_REGULARDATA);
    NextInstruction(CurrentScript, instruction_temp);

  end
  else if (fCurrentInputSymbol = _stringSym) then
  begin
    Get;

    AddParam(instruction_temp, parse_string(lexstring), DATA_TYPE_REGULARDATA);
    NextInstruction(CurrentScript, instruction_temp);

  end
  else
  begin
    SynError(51);
  end;
end;

procedure TAdventureScript._RegularCommand;
begin
  Expect(identifierSym);

  instruction_temp := AddInstruction(CurrentScript, OP_FUNCTIONCALL);
  if (isValidFunctionName(CurrentScript, lexstring) = false) then
  begin
    SemError(47, lexstring);
  end;
  AddParam(instruction_temp, lexstring, DATA_TYPE_FUNCTION_NAME);

  Expect(_lparenSym);
  if (fCurrentInputSymbol = identifierSym) OR (fCurrentInputSymbol = numberSym)
    OR (fCurrentInputSymbol = _stringSym) then
  begin
    _Param;
    while (fCurrentInputSymbol = _commaSym) do
    begin
      Get;
      _Param;
    end;
  end;
  Expect(_rparenSym);

  NextInstruction(CurrentScript, instruction_temp);

end;

procedure TAdventureScript._RandomChance;
begin
  Expect(RANDOMCHANCESym);

  instruction_temp := AddInstruction(CurrentScript, OP_RANDOMCHANCE);

  Expect(_lparenSym);
  Expect(numberSym);

  AddParam(instruction_temp, strtoint(lexstring), DATA_TYPE_PROBABILITY);

  Expect(_rparenSym);
  Expect(SETSym);
  Expect(TARGET_underscoreNODESym);
  Expect(_stringSym);

  AddParam(instruction_temp, parse_string(lexstring), DATA_TYPE_TARGETNODE);
  NextInstruction(CurrentScript, instruction_temp);

end;

procedure TAdventureScript._Param;
begin
  if (fCurrentInputSymbol = _stringSym) then
  begin
    Get;

    AddParam(instruction_temp, parse_string(lexstring),
      DATA_TYPE_PARAMETER_STRING);

  end
  else if (fCurrentInputSymbol = numberSym) then
  begin
    Get;

    AddParam(instruction_temp, strtoint(lexstring), DATA_TYPE_PARAMETER_INT);

  end
  else if (fCurrentInputSymbol = identifierSym) then
  begin
    Get;

    AddParam(instruction_temp, lexstring, DATA_TYPE_PARAMETER_VARIABLEREF);

  end
  else
  begin
    SynError(52);
  end;
end;

procedure TAdventureScript._FunctionParam;
begin
  if (fCurrentInputSymbol = INTSym) then
  begin
    Get;

    AddParam(instruction_temp, PARAM_TYPE_INT,
      DATA_TYPE_FUNCTION_PARAMETER_TYPE);

  end
  else if (fCurrentInputSymbol = STRSym) then
  begin
    Get;

    AddParam(instruction_temp, PARAM_TYPE_STRING,
      DATA_TYPE_FUNCTION_PARAMETER_TYPE);

  end
  else
  begin
    SynError(53);
  end;
  if (fCurrentInputSymbol = _stringSym) then
  begin
    Get;

    AddParam(instruction_temp, parse_string(lexstring),
      DATA_TYPE_FUNCTION_PARAMETER);

  end
  else if (fCurrentInputSymbol = numberSym) then
  begin
    Get;

    AddParam(instruction_temp, strtoint(lexstring),
      DATA_TYPE_FUNCTION_PARAMETER);

  end
  else if (fCurrentInputSymbol = identifierSym) then
  begin
    Get;

    AddParam(instruction_temp, lexstring, DATA_TYPE_FUNCTION_PARAMETER);

  end
  else
  begin
    SynError(54);
  end;
end;

procedure TAdventureScript._Command;
begin
  if (fCurrentInputSymbol = identifierSym) then
  begin
    _RegularCommand;
  end
  else if (fCurrentInputSymbol = SETVARSym) then
  begin
    _SetVar;
  end
  else if (fCurrentInputSymbol = RANDOMCHANCESym) then
  begin
    _RandomChance;
  end
  else
  begin
    SynError(55);
  end;
  Expect(_semicolonSym);
end;

procedure TAdventureScript._IfStatement;
begin

  instruction_temp := AddInstruction(CurrentScript, OP_CONDITION_BLOCK_START);
  NextInstruction(CurrentScript, instruction_temp);

  Expect(IFSym);

  instruction_temp := AddInstruction(CurrentScript, OP_IF);
  NextInstruction(CurrentScript, instruction_temp);

  _Conditions;
  instruction_temp := AddInstruction(CurrentScript, OP_END_CONDITIONLIST);
  NextInstruction(CurrentScript, instruction_temp);

  Expect(_lbraceSym);

  instruction_temp := AddInstruction(CurrentScript, OP_IFBEGIN);
  NextInstruction(CurrentScript, instruction_temp);

  while (fCurrentInputSymbol = identifierSym) OR
    (fCurrentInputSymbol = RANDOMCHANCESym) OR
    (fCurrentInputSymbol = SETVARSym) do
  begin
    _Command;
  end;
  Expect(_rbraceSym);

  instruction_temp := AddInstruction(CurrentScript, OP_IFEND);
  NextInstruction(CurrentScript, instruction_temp);

  if (fCurrentInputSymbol = ELSESym) then
  begin
    while (fCurrentInputSymbol = ELSESym) do
    begin
      Get;

      instruction_temp := AddInstruction(CurrentScript, OP_IF_ELSE);
      NextInstruction(CurrentScript, instruction_temp);

      if (fCurrentInputSymbol = IFSym) then
      begin
        Get;

        instruction_temp := AddInstruction(CurrentScript, OP_IF_CHAINED);
        NextInstruction(CurrentScript, instruction_temp);

        _Conditions;

        instruction_temp := AddInstruction(CurrentScript, OP_END_CONDITIONLIST);
        NextInstruction(CurrentScript, instruction_temp);

      end;
      Expect(_lbraceSym);

      instruction_temp := AddInstruction(CurrentScript, OP_IFELSEBEGIN);
      NextInstruction(CurrentScript, instruction_temp);

      while (fCurrentInputSymbol = identifierSym) OR
        (fCurrentInputSymbol = RANDOMCHANCESym) OR
        (fCurrentInputSymbol = SETVARSym) do
      begin
        _Command;
      end;
      Expect(_rbraceSym);
      instruction_temp := AddInstruction(CurrentScript, OP_IFELSEEND);
      NextInstruction(CurrentScript, instruction_temp);

    end;
  end;

  instruction_temp := AddInstruction(CurrentScript, OP_CONDITION_BLOCK_END);
  NextInstruction(CurrentScript, instruction_temp);

end;

procedure TAdventureScript._Conditions;
begin
  _Condition;
  while (fCurrentInputSymbol = _and_andSym) OR
    (fCurrentInputSymbol = _barSym) do
  begin
    if (fCurrentInputSymbol = _and_andSym) then
    begin
      Get;

      instruction_temp := AddInstruction(CurrentScript, OP_IF_CONNECTOR);
      AddParam(instruction_temp, IF_CONNECT_AND, DATA_TYPE_IF_CONNECTOR);
      NextInstruction(CurrentScript, instruction_temp);

    end
    else
    begin
      Get;

      instruction_temp := AddInstruction(CurrentScript, OP_IF_CONNECTOR);
      AddParam(instruction_temp, IF_CONNECT_OR, DATA_TYPE_IF_CONNECTOR);
      NextInstruction(CurrentScript, instruction_temp);

    end;
    _Condition;
  end;
end;

procedure TAdventureScript._Condition;
begin

  instruction_temp := AddInstruction(CurrentScript, OP_CONDITION);

  Expect(_lparenSym);
  Expect(identifierSym);

  AddParam(instruction_temp, lexstring, DATA_TYPE_IF_VARIABLE);

  case fCurrentInputSymbol of
    _equal_equalSym:
      begin
        Get;

        AddParam(instruction_temp, IF_EVAL_EQUALS, DATA_TYPE_IF_EVAL);

      end;
    _bang_equalSym:
      begin
        Get;

        AddParam(instruction_temp, IF_EVAL_NOT_EQUAL, DATA_TYPE_IF_EVAL);

      end;
    _greaterSym:
      begin
        Get;

        AddParam(instruction_temp, IF_EVAL_LARGER, DATA_TYPE_IF_EVAL);

      end;
    _greater_equalSym:
      begin
        Get;

        AddParam(instruction_temp, IF_EVAL_LARGER_OR_EQUAL, DATA_TYPE_IF_EVAL);

      end;
    _less_equalSym:
      begin
        Get;

        AddParam(instruction_temp, IF_EVAL_LESS_OR_EQUAL, DATA_TYPE_IF_EVAL);

      end;
    _lessSym:
      begin
        Get;

        AddParam(instruction_temp, IF_EVAL_LESS, DATA_TYPE_IF_EVAL);

      end;
  else
    begin
      SynError(56);
    end;
  end;
  if (fCurrentInputSymbol = _stringSym) then
  begin
    Get;

    AddParam(instruction_temp, parse_string(lexstring), DATA_TYPE_IF_VALUE);

  end
  else if (fCurrentInputSymbol = numberSym) then
  begin
    Get;

    AddParam(instruction_temp, strtoint(lexstring), DATA_TYPE_IF_VALUE);

  end
  else if (fCurrentInputSymbol = identifierSym) then
  begin
    Get;

    AddParam(instruction_temp, lexstring, DATA_TYPE_IF_VALUE);

  end
  else
  begin
    SynError(57);
  end;
  Expect(_rparenSym);

  NextInstruction(CurrentScript, instruction_temp);

  if GetScanner.fLastCommentList.Count > 0 then
  begin
    if Assigned(fInternalGrammarComment) then
      fInternalGrammarComment(self, GetScanner.fLastCommentList);
    GetScanner.fLastCommentList.Clear;
  end;
end;

function TAdventureScript.GetBuildDate: TDateTime;
const
  BDate = 43870;
  Hour = 16;
  Min = 57;
begin
  Result := BDate + EncodeTime(Hour, Min, 0, 0);
end;

function TAdventureScript.GetVersion: ansistring;
begin
  Result := '1.0.0.0';
end;

function TAdventureScript.GetVersionStr: ansistring;
begin
  Result := '1.0.0.0';
end;

procedure TAdventureScript.SetVersion(const Value: ansistring);
begin
  // This is a read only property. However, we want the value
  // to appear in the Object Inspector during design time.
end;

procedure TAdventureScript.Parse;
begin
  errDist := minErrDist;
  GetScanner._Reset;
  Get;
  _AdventureScript;
end; { Parse }

procedure TAdventureScript.InitSymSet;
begin
  symSet[0, 0] := [EOFSYMB];
  symSet[0, 1] := [];
  symSet[0, 2] := [];
  symSet[1, 0] := [identifierSym];
  symSet[1, 1] := [IFSym - 16, RANDOMCHANCESym - 16, SETVARSym - 16];
  symSet[1, 2] := [SWITCHSym - 32, FORSym - 32];
  symSet[2, 0] := [identifierSym, numberSym, _stringSym];
  symSet[2, 1] := [_plusSym - 16, _minusSym - 16, _slashSym - 16,
    _starSym - 16];
  symSet[2, 2] := [];
end; { InitSymSet }

end { AdventureScript }

  .
